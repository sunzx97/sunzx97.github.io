<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>sunzx&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="sunzx&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="sunzx&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="sunzx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="sunzx's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sunzx&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-基于python及c-的海康摄像头二次开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/05/%E5%9F%BA%E4%BA%8Epython%E5%8F%8Ac-%E7%9A%84%E6%B5%B7%E5%BA%B7%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2023-08-05T09:31:58.000Z" itemprop="datePublished">2023-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/05/%E5%9F%BA%E4%BA%8Epython%E5%8F%8Ac-%E7%9A%84%E6%B5%B7%E5%BA%B7%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/">基于python及c++的海康摄像头二次开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在工程应用中特别是图像处理领域数据的来源就是摄像头，为了更好地利用这个摄像头资源可能需要调用摄像头的SDK对摄像头的行为进行控制，以下针对海康摄像头，从python和c++两种语言讲解海康摄像头SDK的调用方法。</p>
<h2 id="环境部署及资源下载（c-）"><a href="#环境部署及资源下载（c-）" class="headerlink" title="环境部署及资源下载（c++）"></a>环境部署及资源下载（c++）</h2><ul>
<li>首先去海康官网下载设备网络SDK和SDK手册</li>
<li>配置c++开发环境，主要是配置头文件及库文件路径，参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_66518283/article/details/128406667">https://blog.csdn.net/m0_66518283/article/details/128406667</a></li>
<li>结合SDK手册和SDK中的demo熟悉SDK调用流程，基本都是先初始化，然后再调用云控制台函数等相关函数控制摄像头：新建项目–&gt;配置头文件，库文件–&gt;把dll文件，以及相关文件夹复制到运行目录 –&gt;根据sdk文档开发相应功能</li>
<li>如果出现报错，可以根据错误码排查问题：<a target="_blank" rel="noopener" href="https://open.hikvision.com/hardware/definitions/NET_DVR_GetLastError.html">https://open.hikvision.com/hardware/definitions/NET_DVR_GetLastError.html</a></li>
<li>比如我在开发的时候发现报107，原来是资源文件没有配置好，参见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42076938/article/details/103195484">https://blog.csdn.net/weixin_42076938/article/details/103195484</a></li>
</ul>
<h2 id="基于python的海康摄像头SDK开发"><a href="#基于python的海康摄像头SDK开发" class="headerlink" title="基于python的海康摄像头SDK开发"></a>基于python的海康摄像头SDK开发</h2><ul>
<li>深度学习一般使用的python框架进行开发，因此还需要考虑对c++与python的交互</li>
<li>海康SDK提供了python的demo代码，原理也是用的ctypes，参考：<a target="_blank" rel="noopener" href="https://www.ryannn.com/archives/hikvision/comment-page-4">https://www.ryannn.com/archives/hikvision/comment-page-4</a></li>
<li>利用ctypes包实现python调用c++代码，大致原理就是将所有的dll文件添加到一个list中，然后一个个遍历调用指定的函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, ctypes</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历动态链接库目录</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_dll</span>(<span class="params">path, dll_list</span>):</span><br><span class="line">    files = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path + file):</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.dll&quot;</span>):</span><br><span class="line">                dll_list.append(path + file)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            add_dll(path + file + <span class="string">&quot;/&quot;</span>, dll_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入动态链接库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callCpp</span>(<span class="params">func_name, *args</span>):</span><br><span class="line">    <span class="keyword">for</span> so_lib <span class="keyword">in</span> so_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            lib = ctypes.cdll.LoadLibrary(so_lib)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = <span class="built_in">eval</span>(<span class="string">&quot;lib.%s&quot;</span> % func_name)(*args)</span><br><span class="line">                <span class="comment"># print(&quot;调用的库：&quot; + so_lib)</span></span><br><span class="line">                <span class="comment"># print(&quot;执行成功,返回值：&quot; + str(value))</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;库文件载入失败：&quot;</span> + so_lib)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有找到接口！&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 云台控制操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">NET_DVR_PTZControl_Other</span>(<span class="params">lUserID, lChannel, dwPTZCommand, dwStop</span>):</span><br><span class="line">    res = callCpp(<span class="string">&quot;NET_DVR_PTZControl_Other&quot;</span>, lUserID, lChannel, dwPTZCommand, dwStop)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;控制成功&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;控制失败: &quot;</span> + <span class="built_in">str</span>(callCpp(<span class="string">&quot;NET_DVR_GetLastError&quot;</span>)))</span><br></pre></td></tr></table></figure></li>
<li>如果SDK中的函数输入是结构体，则在python中需要进行如下构造：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓图数据结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NET_DVR_JPEGPARA</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;wPicSize&quot;</span>, ctypes.c_ushort), <span class="comment"># WORD</span></span><br><span class="line">        (<span class="string">&quot;wPicQuality&quot;</span>, ctypes.c_ushort)] <span class="comment"># WORD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># jpeg 抓图</span></span><br><span class="line"><span class="comment"># hPlayWnd 显示窗口可以为 none；存在缺点采集图片速度慢</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">NET_DVR_CaptureJPEGPicture</span>():</span><br><span class="line">    sJpegPicFileName = <span class="built_in">bytes</span>(<span class="string">&quot;pytest.jpg&quot;</span>, <span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">    lpJpegPara = NET_DVR_JPEGPARA()</span><br><span class="line">    lpJpegPara.wPicSize = <span class="number">2</span></span><br><span class="line">    lpJpegPara.wPicQuality = <span class="number">1</span></span><br><span class="line">    res = callCpp(<span class="string">&quot;NET_DVR_CaptureJPEGPicture&quot;</span>, lUserID, lChannel, ctypes.byref(lpJpegPara), sJpegPicFileName)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="literal">False</span>:</span><br><span class="line">        error_info = callCpp(<span class="string">&quot;NET_DVR_GetLastError&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;抓图失败：&quot;</span> + <span class="built_in">str</span>(error_info))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;抓图成功&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>设计到结构体时可能python的类型和c++的类型不知道怎么设置，可以参考：<a target="_blank" rel="noopener" href="https://www.codenong.com/jsc3c4bf3d1ef8/">https://www.codenong.com/jsc3c4bf3d1ef8/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/05/%E5%9F%BA%E4%BA%8Epython%E5%8F%8Ac-%E7%9A%84%E6%B5%B7%E5%BA%B7%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/" data-id="clky8whzd000dhcu5fttobh58" data-title="基于python及c++的海康摄像头二次开发" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-基于python的循环队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2023-06-21T15:09:50.000Z" itemprop="datePublished">2023-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/">基于python的循环队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有时可能需要一个循环队列实时保存数据，比如使用循环队列实时保存一段视频数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;环形队列&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size=<span class="number">90</span></span>):</span><br><span class="line">        self.queue = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        self.size = size</span><br><span class="line">        self.rear = <span class="number">0</span>  <span class="comment"># 队尾指针</span></span><br><span class="line">        self.front = <span class="number">0</span>  <span class="comment"># 队首指针</span></span><br><span class="line">        self.lock = <span class="literal">False</span></span><br><span class="line">        self.boat_in_write = <span class="literal">None</span></span><br><span class="line">        self.boat_in = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;进队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.lock:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.is_full():</span><br><span class="line">                self.rear = (self.rear + <span class="number">1</span>) % self.size  <span class="comment"># 队尾指针前移</span></span><br><span class="line">                self.queue[self.rear] = item</span><br><span class="line">                <span class="comment"># print(&quot;inset item: &quot;, self.queue)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 队列已满，前面入队的出队</span></span><br><span class="line">                self.front = (self.front + <span class="number">1</span>) % self.size  <span class="comment"># 队首指针前移</span></span><br><span class="line">                self.rear = (self.rear + <span class="number">1</span>) % self.size  <span class="comment"># 队尾指针前移</span></span><br><span class="line">                self.queue[self.rear] = item</span><br><span class="line">                <span class="keyword">if</span> self.boat_in:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;save boat in&quot;</span>)</span><br><span class="line">                    self.save_queue(self.boat_in_write)</span><br><span class="line">                    self.boat_in = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出队&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            self.front = (self.front + <span class="number">1</span>) % self.size  <span class="comment"># 队首指针前移</span></span><br><span class="line">            <span class="keyword">return</span> self.queue[self.front]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断环形队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.front == self.rear</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_full</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断环形队列是否已满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear + <span class="number">1</span>) % self.size == self.front</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_queue</span>(<span class="params">self, out_write=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始保存视频&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;数组非空&quot;</span>)</span><br><span class="line">            self.lock = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> out_write <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;write is not none&quot;</span>)</span><br><span class="line">                temp_front = self.front</span><br><span class="line">                <span class="keyword">while</span> temp_front != self.rear:</span><br><span class="line">                    out_write.write(self.queue[temp_front])</span><br><span class="line">                    temp_front = (temp_front + <span class="number">1</span>) % self.size  <span class="comment"># 前移</span></span><br><span class="line">                out_write.release()</span><br><span class="line">            self.lock = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_queue_wait</span>(<span class="params">self, out_write=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># 清空数组</span></span><br><span class="line">        self.front = self.rear</span><br><span class="line">        self.boat_in = <span class="literal">True</span></span><br><span class="line">        self.boat_in_write = out_write</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        <span class="comment">#     # 如果已经跑了一圈</span></span><br><span class="line">        <span class="comment">#     if self.is_full:</span></span><br><span class="line">        <span class="comment">#         self.save_queue(out_write)</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_mean</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">round</span>(<span class="built_in">sum</span>(self.queue) / self.size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_queue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.queue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">record = CircleQueue(<span class="number">600</span>)</span><br><span class="line">cam = cv2.VideoCapture(<span class="string">&#x27;rtsp://&#x27;</span>)</span><br><span class="line">fps = cam.get(cv2.CAP_PROP_FPS)</span><br><span class="line">size = (<span class="built_in">int</span>(cam.get(cv2.CAP_PROP_FRAME_WIDTH)), <span class="built_in">int</span>(cam.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line">size2 = (<span class="number">640</span>, <span class="number">320</span>)</span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">&#x27;mp4v&#x27;</span>)</span><br><span class="line">dir_save_path = <span class="string">&quot;./video_out/&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_record</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = cam.read()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> ret:</span><br><span class="line">            frame = cv2.resize(frame, size2)</span><br><span class="line">            record.enqueue(frame)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boat</span>(<span class="params">ai_name=<span class="string">&#x27;yolov3_darknet_boat&#x27;</span>, cam_name=<span class="string">&#x27;乌弄龙坝上放流&#x27;</span></span>):</span><br><span class="line">    <span class="comment"># 连接配置表查询摄像头id及算法id</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cur_iec = sqlite3.connect(<span class="string">r&quot;easyedge-iec.db&quot;</span>)</span><br><span class="line">        ai_cur = cur_iec.execute(<span class="string">&quot;SELECT uuid FROM aiservice where name=&#x27;&#123;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(ai_name))</span><br><span class="line">        ai_id = ai_cur.fetchall()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        cam_cur = cur_iec.execute(<span class="string">&quot;SELECT uuid FROM camera where name=&#x27;&#123;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(cam_name))</span><br><span class="line">        cam_id = cam_cur.fetchall()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        ai_cur.close()</span><br><span class="line">        cam_cur.close()</span><br><span class="line">        cur_iec.close()</span><br><span class="line">        <span class="built_in">print</span>(ai_id, cam_id, <span class="built_in">type</span>(cam_id), <span class="built_in">str</span>(ai_id))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        time.sleep(<span class="number">40</span>)</span><br><span class="line">        boat(ai_name=ai_name, cam_name=cam_name)</span><br><span class="line">  </span><br><span class="line">    last_date = datetime.datetime.now()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;now time type:&quot;</span>, last_date, <span class="built_in">type</span>(last_date))</span><br><span class="line">    time.sleep(<span class="number">30</span>)</span><br><span class="line">    <span class="comment"># 根据算法id和摄像头id及时间查询数据</span></span><br><span class="line">    cur_event = sqlite3.connect(<span class="string">r&quot;easyedge-event.db&quot;</span>)</span><br><span class="line">    last_boat_num = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cur_time = datetime.datetime.now()</span><br><span class="line">        boat_cur = cur_event.execute(<span class="string">&quot;SELECT eventtime, result FROM event_record where serviceUUID=&#x27;&#123;&#125;&#x27; and cameraUUID=&#x27;&#123;&#125;&#x27; and eventTime&gt;&#x27;&#123;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(ai_id, cam_id, last_date))</span><br><span class="line">        boat_result = boat_cur.fetchall()</span><br><span class="line">        <span class="comment"># print(&quot;boat_result: &#123;&#125;&quot;.format(boat_result))</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(boat_result) &gt; <span class="number">0</span>:</span><br><span class="line">            fps_ai = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 计算帧数</span></span><br><span class="line">            frame_num = (cur_time - last_date).seconds * fps_ai</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;总帧数&quot;</span>, frame_num)</span><br><span class="line">            <span class="comment"># 统计这段时间内船舶数量的平均数</span></span><br><span class="line">            boat_num_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(boat_result)):</span><br><span class="line">                _, bbox = boat_result[i]</span><br><span class="line">                bbox = bbox.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                bbox = json.loads(bbox)</span><br><span class="line"></span><br><span class="line">                cur_boat_num = <span class="built_in">len</span>(bbox)</span><br><span class="line">                boat_num_sum += cur_boat_num</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;boat_num_sum: &quot;</span>, boat_num_sum)</span><br><span class="line">            boat_num_mean = <span class="built_in">round</span>(boat_num_sum / frame_num)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;船舶平均数&quot;</span>, boat_num_mean)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            boat_num_mean = <span class="number">0</span></span><br><span class="line">        last_date = cur_time</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">if</span> last_boat_num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;设置初始boat数量&quot;</span>)</span><br><span class="line">            <span class="comment"># last_boat_num = boat_num_mean</span></span><br><span class="line">        <span class="comment"># 出港</span></span><br><span class="line">        <span class="keyword">elif</span> last_boat_num &gt; boat_num_mean:</span><br><span class="line">            output_path = os.path.join(dir_save_path, datetime.datetime.strftime(datetime.datetime.now(), <span class="string">&#x27;%Y_%m_%d_%H_%M_%S&#x27;</span>) + <span class="string">&quot;out.mp4&quot;</span>)</span><br><span class="line">            out = cv2.VideoWriter(output_path, fourcc, fps, size2)</span><br><span class="line">            record.save_queue(out)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;有出港事件发生&quot;</span>)</span><br><span class="line">        <span class="comment"># 进港</span></span><br><span class="line">        <span class="keyword">elif</span> last_boat_num &lt; boat_num_mean:</span><br><span class="line">            output_path = os.path.join(dir_save_path, datetime.datetime.strftime(datetime.datetime.now(),<span class="string">&#x27;%Y_%m_%d_%H_%M_%S&#x27;</span>) + <span class="string">&quot;in.mp4&quot;</span>)</span><br><span class="line">            out = cv2.VideoWriter(output_path, fourcc, fps, size2)</span><br><span class="line">            record.save_queue_wait(out)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;有进港事件发生&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;无进出港口事件发生，当前船数量:&quot;</span>, boat_num_mean)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置间隔时间</span></span><br><span class="line">        last_boat_num = boat_num_mean</span><br><span class="line">        time.sleep(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    eventprocess = threading.Thread(target=boat)</span><br><span class="line">    videoprocess = threading.Thread(target=add_record)</span><br><span class="line">    eventprocess.start()</span><br><span class="line">    videoprocess.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/" data-id="clky8whzb000chcu51gvmhdp5" data-title="基于python的循环队列" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-pytorch及其他一些深度学习python库介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/19/pytorch%E5%8F%8A%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0python%E5%BA%93%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2023-04-19T15:13:23.000Z" itemprop="datePublished">2023-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/19/pytorch%E5%8F%8A%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0python%E5%BA%93%E4%BB%8B%E7%BB%8D/">pytorch及其他一些深度学习python库介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文介绍pytorch框架及其他一些深度学习python库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/19/pytorch%E5%8F%8A%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0python%E5%BA%93%E4%BB%8B%E7%BB%8D/" data-id="clky8whz30005hcu5927v54ra" data-title="pytorch及其他一些深度学习python库介绍" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-m3u8视频下载" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/07/m3u8%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/" class="article-date">
  <time class="dt-published" datetime="2023-04-07T12:07:15.000Z" itemprop="datePublished">2023-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/07/m3u8%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/">m3u8视频下载</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文介绍如何HLS协议相关知识。</p>
<h2 id="HLS协议"><a href="#HLS协议" class="headerlink" title="HLS协议"></a>HLS协议</h2><p>HLS（HTTP Live Streaming）是一种基于http协议的流媒体网络传输协议，很多视频都是通过该协议传输，主要原理就是将视频切分为很多片段，通过一个索引文件m3u8对切分后的视频ts片段进行检索。<br><img src="/../images/hls_fra.png"></p>
<p>关于m3u8中字段的意义如下：</p>
<p>   #EXTM3U 指明这是一个m3u8文件<br>   #EXT-X-TARGETDURATION:10 指明每个片段最多10s</p>
<p>   #EXTINF:9.009,<br>   <a target="_blank" rel="noopener" href="http://media.example.com/first.ts">http://media.example.com/first.ts</a>  指明片段地址以及片段时长<br>   #EXTINF:9.009,<br>   <a target="_blank" rel="noopener" href="http://media.example.com/second.ts">http://media.example.com/second.ts</a><br>   #EXTINF:3.003,<br>   <a target="_blank" rel="noopener" href="http://media.example.com/third.ts">http://media.example.com/third.ts</a></p>
<p>以下为更详细的字段</p>
<p>#EXTM3U:每个M3U文件第一行必须是这个tag标识。(简单了解)</p>
<p>#EXT-X-VERSION:版本，此属性可用可不用。(简单了解)</p>
<p>#EXT-X-TARGETDURATION:目标持续时间，是用来定义每个TS的【最大】duration（持续时间）。(简单了解)</p>
<p>#EXT-X-ALLOW-CACHE是否允许允许高速缓存。(简单了解)</p>
<p>#EXT-X-MEDIA-SEQUENCE定义当前M3U8文件中第一个文件的序列号，每个ts文件在M3U8文件中都有固定唯一的序列号。(简单了解)</p>
<p>#EXT-X-DISCONTINUITY:播放器重新初始化(简单了解)</p>
<p>#EXT-X-KEY定义加密方式，用来加密的密钥文件key的URL，加密方法（例如AES-128），以及IV加密向量。（记住）</p>
<p>#EXTINF:指定每个媒体段(ts文件)的持续时间，这个仅对其后面的TS链接有效，每两个媒体段(ts文件)间被这个tag分隔开。(简单了解)</p>
<p>#EXT-X-ENDLIST表明M3U8文件的结束。(简单了解)</p>
<h2 id="python实现基于HLS的流媒体文件获取"><a href="#python实现基于HLS的流媒体文件获取" class="headerlink" title="python实现基于HLS的流媒体文件获取"></a>python实现基于HLS的流媒体文件获取</h2><p>由HLS协议的原理可知，解析HLS文件先要找到m3u8索引文件，然后获取视频片段进行拼接。<br>解析m3u8文件可以根据一些开源库或开源代码，这里贴一些在网上找的代码，仅作参考。</p>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Crypto 包 中的AES 对加密的ts片段进行解密，通过 pycryptodome 库安装Crypto包，如果安装后还是报找不到该包，找到安装包的位置将小写的cryto改成Crypto</span></span><br><span class="line"><span class="comment"># pip install pycryptodome</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">dirName = <span class="string">&#x27;tsLib&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dirName):</span><br><span class="line">    os.mkdir(dirName)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一级m3u8地址</span></span><br><span class="line">m1_url = <span class="string">&#x27;https://v4.cdtlas.com/20220311/xEaAxRVd/index.m3u8&#x27;</span></span><br><span class="line"><span class="comment"># 由于HLS 是基于 HTTP的，所以直接requests.get</span></span><br><span class="line">m1_page_text = requests.get(url=m1_url,headers=headers).text</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(m1_page_text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从一级m3u8文件中解析出二级m3u8地址</span></span><br><span class="line">m1_page_text = m1_page_text.strip() <span class="comment">#取出收尾的回车</span></span><br><span class="line"><span class="comment"># 二级m3u8地址</span></span><br><span class="line">m2_url = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line  <span class="keyword">in</span> m1_page_text.split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line.startswith(<span class="string">&#x27;#&#x27;</span>):</span><br><span class="line"></span><br><span class="line">        m2_url = line</span><br><span class="line">        <span class="comment"># 将m1_url 和m2_url不同之处补充到m2_url中</span></span><br><span class="line">        m2_url = urljoin(m1_url,m2_url)</span><br><span class="line">        <span class="comment"># 至此就获取到了完整的二级文件地址</span></span><br><span class="line"><span class="comment"># 请求链接地址</span></span><br><span class="line"><span class="comment"># print(m2_url)</span></span><br><span class="line"><span class="comment"># 请求二级文件地址内容</span></span><br><span class="line">m2_page_text = requests.get(url=m2_url,headers=headers).text</span><br><span class="line">m2_page_text = m2_page_text.strip()</span><br><span class="line"><span class="comment"># print(m2_page_text) # 打印输出整个.ts文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析出解密秘钥key的地址</span></span><br><span class="line">key_url = re.findall(<span class="string">&#x27;URI=&quot;(.*?)&quot;&#x27;</span>,m2_page_text,re.S)[<span class="number">0</span>]</span><br><span class="line">key_url =urljoin(m1_url,key_url)</span><br><span class="line"><span class="comment"># print(key_url) # 打印请求链接地址 https://iqiyi.shanshanku.com/20211104/6AoEDjLD/1200kb/hls/key.key</span></span><br><span class="line"><span class="comment"># 请求key的地址，获取知秘钥</span></span><br><span class="line">    <span class="comment"># 注意： key和iv需要为bytes类型</span></span><br><span class="line">key = requests.get(url=key_url,headers=headers).content</span><br><span class="line">iv = <span class="string">b&#x27;0000000000000000&#x27;</span></span><br><span class="line"><span class="comment"># print(key) # 得到解密密钥</span></span><br><span class="line"><span class="comment"># 解析出每一个ts切片的地址</span></span><br><span class="line">ts_url_list = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> m2_page_text.split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">        ts_url = line</span><br><span class="line">        ts_url = urljoin(m1_url,ts_url)</span><br><span class="line">        ts_url_list.append(ts_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(ts_url_list) # 列表组成的逗号分隔的.ts文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步请求到每一个ts切片的数据</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_ts</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> <span class="keyword">await</span> sess.get(url=url,headers=headers) <span class="keyword">as</span> response:</span><br><span class="line">            ts_data = <span class="keyword">await</span> response.read() <span class="comment"># 获取byte形式的响应数据</span></span><br><span class="line">            <span class="comment"># 需要对ts片段数据进行解密（需要用到key和iv）</span></span><br><span class="line">            aes = AES.new(key=key, mode=AES.MODE_CBC, iv=iv)</span><br><span class="line">            desc_data = aes.decrypt(ts_data)  <span class="comment"># 获取了解密后的数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> [desc_data,url]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">t</span>):</span><br><span class="line">    r_list = t.result()</span><br><span class="line">    data =r_list[<span class="number">0</span>]</span><br><span class="line">    url = r_list[<span class="number">1</span>] <span class="comment"># ts文件的地址</span></span><br><span class="line">    ts_name = url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    ts_path = dirName + <span class="string">&#x27;/&#x27;</span> + ts_name</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(ts_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="comment"># 需要将解密后的数据写入文件进行保存</span></span><br><span class="line">        fp.write(data)</span><br><span class="line">    <span class="built_in">print</span>(ts_name, <span class="string">&#x27;下载保存成功！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">tasks = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> ts_url_list:</span><br><span class="line">    c = get_ts(url)</span><br><span class="line">    task = asyncio.ensure_future(c)</span><br><span class="line">    task.add_done_callback(download)</span><br><span class="line">    tasks.append(task)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">                <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Edg/86.0.622.56&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">m3u8</span>(<span class="params">url,movie_name</span>):</span><br><span class="line">    base_url = url[:url.rfind(<span class="string">&#x27;/&#x27;</span>)+<span class="number">1</span>]<span class="comment">#用于拼接url</span></span><br><span class="line">    rs = requests.get(url,headers=headers).text</span><br><span class="line">    list_content = rs.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    player_list = []</span><br><span class="line">    <span class="comment">#创建文件夹，用于存放ts文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(movie_name)):</span><br><span class="line">        <span class="comment">#os.system(&#x27;mkdir merge&#x27;)</span></span><br><span class="line">        os.mkdir(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(movie_name))</span><br><span class="line">    key = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> index,line <span class="keyword">in</span> <span class="built_in">enumerate</span>(list_content):</span><br><span class="line">        <span class="comment"># 判断视频是否经过AES-128加密</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;#EXT-X-KEY&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            method_pos = line.find(<span class="string">&quot;METHOD&quot;</span>)</span><br><span class="line">            comma_pos = line.find(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            method = line[method_pos:comma_pos].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]<span class="comment">#获取加密方式</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Decode Method：&quot;</span>, method)</span><br><span class="line">            uri_pos = line.find(<span class="string">&quot;URI&quot;</span>)</span><br><span class="line">            quotation_mark_pos = line.rfind(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">            key_path = line[uri_pos:quotation_mark_pos].split(<span class="string">&#x27;&quot;&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            key_url = key_path</span><br><span class="line">            res = requests.get(key_url,headers=headers)</span><br><span class="line">            key = res.content   <span class="comment">#获取加密密钥</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#print(&quot;key：&quot;, key)</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取.ts文件链接地址方式可根据需要进行定制</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;#EXTINF&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            <span class="comment"># 获取每一媒体序列的.ts文件链接地址</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;http&#x27;</span> <span class="keyword">in</span> list_content[index + <span class="number">1</span>]:</span><br><span class="line">                href = list_content[index + <span class="number">1</span>]</span><br><span class="line">                player_list.append(href)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                href = base_url + list_content[index+<span class="number">1</span>]</span><br><span class="line">                player_list.append(href)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;此视频经过加密&#x27;</span>)</span><br><span class="line">        <span class="comment">#print(player_list)#打印ts地址列表</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(player_list):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(movie_name + <span class="built_in">str</span>(i+<span class="number">1</span>) + <span class="string">&#x27;.ts&#x27;</span>)):</span><br><span class="line">                cryptor = AES.new(key, AES.MODE_CBC, key)</span><br><span class="line">                res = requests.get(j,headers=headers)</span><br><span class="line">                requests.adapters.DEFAULT_RETRIES = <span class="number">5</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(movie_name) + <span class="built_in">str</span>(i+<span class="number">1</span>) + <span class="string">&#x27;.ts&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                    file.write(cryptor.decrypt(res.content))<span class="comment">#将解密后的视频写入文件</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;正在写入第&#123;&#125;个文件&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">                    <span class="comment">#time.sleep(5)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#print(i)</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;此视频未加密&#x27;</span>)</span><br><span class="line">        <span class="comment">#print(player_list)#打印ts地址列表</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(player_list):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(movie_name + <span class="built_in">str</span>(i+<span class="number">1</span>) + <span class="string">&#x27;.ts&#x27;</span>)):</span><br><span class="line">                res = requests.get(j,headers=headers)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(movie_name) + <span class="built_in">str</span>(i+<span class="number">1</span>) + <span class="string">&#x27;.ts&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                    file.write(res.content)<span class="comment">#将解密后的视频写入文件</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;正在写入第&#123;&#125;个文件&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;nz&#x27;</span></span><br><span class="line">url = <span class="string">&quot;https://vod3.buycar5.cn/20210402/Z4mMbiNW/1000kb/hls/index.m3u8&quot;</span></span><br><span class="line">m3u8(url,name)</span><br></pre></td></tr></table></figure>

<h3 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码来源：https://blog.csdn.net/as604049322/article/details/118314130</span></span><br><span class="line"><span class="comment"># 原博客为 下载 B 站 实时视频</span></span><br><span class="line"><span class="comment"># 根据实际场景进行一定改写</span></span><br><span class="line"><span class="comment"># 其中 get_real_url 函数用于处理多层 m3u8 index 的情况，即嵌套 m3u8</span></span><br><span class="line"><span class="comment"># get_live_url 是针对 B站写的，没必要了解</span></span><br><span class="line"><span class="comment"># down_video 就是根据 m3u8链接下载视频，从代码来看就是用了一个循环，在考虑这样会不会出现掉帧的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> m3u8</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_live_url</span>(<span class="params">cid, platform=<span class="string">&#x27;h5&#x27;</span></span>):</span><br><span class="line">    playUrl = <span class="string">&#x27;https://api.live.bilibili.com/xlive/web-room/v1/playUrl/playUrl&#x27;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;cid&#x27;</span>: cid,  <span class="comment"># cid序列号</span></span><br><span class="line">        <span class="string">&#x27;qn&#x27;</span>: <span class="number">150</span>,  <span class="comment"># 播放的视频质量</span></span><br><span class="line">        <span class="string">&#x27;platform&#x27;</span>: platform,  <span class="comment"># 视频的播放形式</span></span><br><span class="line">        <span class="string">&#x27;ptype&#x27;</span>: <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(playUrl, headers=headers, params=params).json()</span><br><span class="line">    text = response[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;durl&#x27;</span>]</span><br><span class="line">    url = text[-<span class="number">1</span>][<span class="string">&#x27;url&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_real_url</span>(<span class="params">url</span>):</span><br><span class="line">    playlist = m3u8.load(uri=url, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> playlist.playlists[<span class="number">0</span>].absolute_uri</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_video</span>(<span class="params">url, max_count=<span class="number">1000</span>, max_size=<span class="number">120</span>*<span class="number">1024</span>*<span class="number">1024</span></span>):</span><br><span class="line">    max_id = <span class="literal">None</span></span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_count+<span class="number">1</span>):</span><br><span class="line">        playlist = m3u8.load(uri=url, headers=headers)</span><br><span class="line">        <span class="keyword">for</span> seg <span class="keyword">in</span> playlist.segments:</span><br><span class="line">            current_id = <span class="built_in">int</span>(seg.uri[<span class="number">1</span>:seg.uri.find(<span class="string">&quot;.&quot;</span>)])</span><br><span class="line">            <span class="keyword">if</span> max_id <span class="keyword">and</span> current_id &lt;= max_id:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;combine.mp4&quot;</span>, <span class="string">&quot;ab&quot;</span> <span class="keyword">if</span> max_id <span class="keyword">else</span> <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                r = requests.get(seg.absolute_uri, headers=headers)</span><br><span class="line">                data = r.content</span><br><span class="line">                size += <span class="built_in">len</span>(data)</span><br><span class="line">                f.write(data)</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;\r下载次数(<span class="subst">&#123;i&#125;</span>/<span class="subst">&#123;max_count&#125;</span>)，已下载：<span class="subst">&#123;size/<span class="number">1024</span>/<span class="number">1024</span>:<span class="number">.2</span>f&#125;</span>MB&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> size &gt;= max_size:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;\n文件已经超过大小限制，下载结束！&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">        max_id = current_id</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = get_live_url(<span class="string">&#x27;22273117&#x27;</span>)</span><br><span class="line">real_url = get_real_url(url)</span><br><span class="line">download_video(real_url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 之前的文件 ts_download_online 是参照一个博客，针对的是b站直播视频的下载</span></span><br><span class="line"><span class="comment"># 把其应用到其他地方发现有一些问题，没有很好的进行去除重复视频的机制</span></span><br><span class="line"><span class="comment"># 在GitHub上找到一个其他的代码，思路可以借鉴</span></span><br><span class="line"><span class="comment"># 了解m3u8原理后进行改写也相对简单</span></span><br><span class="line"><span class="comment"># 以下代码源于：https://github.com/1chandan1/StreamDownload</span></span><br><span class="line"><span class="comment"># 核心思想就是添加一个数组保存已经下载好的url，然后每次下载之前都检查一下数组中是否已经有该url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> m3u8</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">check = []</span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">stop = <span class="literal">False</span></span><br><span class="line">Vname = <span class="built_in">input</span>(<span class="string">&quot;Video name :&quot;</span>)</span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&quot;Enter the m3u8 link of the resolution that you want:&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        m3u8_master = m3u8.loads(r.text)</span><br><span class="line">        m3u8_master.data[<span class="string">&#x27;playlists&#x27;</span>][-<span class="number">1</span>][<span class="string">&#x27;uri&#x27;</span>]</span><br><span class="line">        url = <span class="built_in">input</span>(</span><br><span class="line">            <span class="string">&quot;\nIt may be the master m3u8 link. Enter link of indivisual resolution which you want :\n&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        Playlist = m3u8.loads(r.text)</span><br><span class="line">        tsfile = Playlist.data[<span class="string">&#x27;segments&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> tsfile == []:</span><br><span class="line">            url = <span class="built_in">input</span>(<span class="string">&quot;\nEnter correct Link :&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        url = <span class="built_in">input</span>(<span class="string">&quot;\nEnter correct Link :&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPress Enter to STOP\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downLink</span>():</span><br><span class="line">    <span class="keyword">global</span> a, run</span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">global</span> stop</span><br><span class="line">        <span class="keyword">if</span> stop:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\nSTOP&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        Playlist = m3u8.loads(r.text)</span><br><span class="line">        tsfile = Playlist.data[<span class="string">&#x27;segments&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> tsfile:</span><br><span class="line">            <span class="keyword">if</span> link[<span class="string">&quot;uri&quot;</span>] <span class="keyword">not</span> <span class="keyword">in</span> check:</span><br><span class="line">                check.append(link[<span class="string">&quot;uri&quot;</span>])</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(time() - start, end=<span class="string">&quot;\r&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> time() - start &gt; <span class="number">3000</span>:</span><br><span class="line">            run = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    <span class="keyword">global</span> a, stop</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    run = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(Vname + <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> run:</span><br><span class="line">            <span class="keyword">if</span> a &gt; b:</span><br><span class="line">                p = requests.get(check[b])</span><br><span class="line">                f.write(p.content)</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> stop:</span><br><span class="line">                f.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">STOP</span>():</span><br><span class="line">    <span class="keyword">global</span> stop</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Thread(target=downLink)</span><br><span class="line">s2 = Thread(target=download)</span><br><span class="line">s3 = Thread(target=STOP)</span><br><span class="line">s1.start()</span><br><span class="line">s2.start()</span><br><span class="line">s3.start()</span><br></pre></td></tr></table></figure>

<p>对于实时视频流原理是一样的，只是需要循环请求m3u8文件获取ts片段路径，另外如果加密就利用Crypto.Cipher包进行解密，解密的输入包括key和iv。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/07/m3u8%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/" data-id="clky8whz40006hcu5c7fmh30h" data-title="m3u8视频下载" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-diffusion-model" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/06/diffusion-model/" class="article-date">
  <time class="dt-published" datetime="2023-03-06T14:54:47.000Z" itemprop="datePublished">2023-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/06/diffusion-model/">diffusion_model</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>原论文：Denoising Diffusion Probabilistic Models<br>以下讲解整个扩散模型流程，不讲解数学推导。<br>diffusion model是一种生成模型，通常使用一个正向的扩散过程和一个反向的逆扩散过程解释其原理。</p>
<p><img src="/../images/diffusion_model_pri.png"></p>
<p>正向的扩散过程通过添加高斯噪声实现。</p>
<p><img src="/../images/diffusion_model_q.png"><br>通过马尔可夫链，经过推导有</p>
<p><img src="/../images/diffusion_model_q2.png"></p>
<p>其中</p>
<p><img src="/../images/diffusion_model_q3.png"></p>
<p>反向过程定义为</p>
<p><img src="/../images/diffusion_model_p.png"></p>
<p>根据马尔可夫链及相关推导有</p>
<p><img src="/../images/diffusion_model_q5.png"></p>
<p>因为有</p>
<p><img src="/../images/diffusion_model_xt.png"></p>
<p>所以上式u_t可以简化为</p>
<p><img src="/../images/diffusion_model_ut.png"></p>
<p>注意以上关于u_t的两种写法都可以，两种写法我在代码中都见过。</p>
<p>loss函数为</p>
<p><img src="/../images/diffusion_model_loss.png"></p>
<p>最终需要优化的损失函数为</p>
<p><img src="/../images/diffusion_model_loss2.png"></p>
<p>这个时候根据不同建模会得到不同的损失函数，如论文是让网络去学习那个正向过程高斯采样的噪音，得到最终的损失函数表达式为</p>
<p><img src="/../images/diffusion_model_loss3.png"></p>
<p>下面结合代码了解各个超参数应用在什么地方, 下面的代码是拟合一个s型曲线，是二维分布。从diffusion model的loss可以知道其是针对点做的损失函数，刚开始我挺迷的这样不丢失了图像的结构信息了嘛，但是后来突然感悟图像的结构信息就蕴藏在要学习的网络中，网络用的是卷积网络呀，都是结合了图像结构信息而学到的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %matplotlib inline</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_s_curve</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">s_curve,_ = make_s_curve(<span class="number">10</span>**<span class="number">4</span>,noise=<span class="number">0.1</span>)</span><br><span class="line">s_curve = s_curve[:,[<span class="number">0</span>,<span class="number">2</span>]]/<span class="number">10.0</span> <span class="comment"># (10000, 2)</span></span><br><span class="line"></span><br><span class="line">data = s_curve.T</span><br><span class="line"></span><br><span class="line">fig,ax = plt.subplots()</span><br><span class="line">ax.scatter(*data,color=<span class="string">&#x27;blue&#x27;</span>,edgecolor=<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dataset = torch.Tensor(s_curve).<span class="built_in">float</span>()  <span class="comment">#(10000, 2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定超参数的值</span></span><br><span class="line">num_steps = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#制定每一步的beta</span></span><br><span class="line">betas = torch.linspace(-<span class="number">6</span>,<span class="number">6</span>,num_steps)</span><br><span class="line">betas = torch.sigmoid(betas)*(<span class="number">0.5e-2</span> - <span class="number">1e-5</span>)+<span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算alpha、alpha_prod、alpha_prod_previous、alpha_bar_sqrt等变量的值</span></span><br><span class="line">alphas = <span class="number">1</span>-betas</span><br><span class="line">alphas_prod = torch.cumprod(alphas,<span class="number">0</span>)</span><br><span class="line">alphas_prod_p = torch.cat([torch.tensor([<span class="number">1</span>]).<span class="built_in">float</span>(),alphas_prod[:-<span class="number">1</span>]],<span class="number">0</span>)</span><br><span class="line">alphas_bar_sqrt = torch.sqrt(alphas_prod)</span><br><span class="line">one_minus_alphas_bar_log = torch.log(<span class="number">1</span> - alphas_prod)</span><br><span class="line">one_minus_alphas_bar_sqrt = torch.sqrt(<span class="number">1</span> - alphas_prod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> alphas.shape==alphas_prod.shape==alphas_prod_p.shape==\</span><br><span class="line">alphas_bar_sqrt.shape==one_minus_alphas_bar_log.shape\</span><br><span class="line">==one_minus_alphas_bar_sqrt.shape</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;all the same shape&quot;</span>,betas.shape) <span class="comment"># (100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定扩散过程任意时刻的采样值</span></span><br><span class="line"><span class="comment">#计算任意时刻的x采样值，基于x_0和重参数化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">q_x</span>(<span class="params">x_0,t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;可以基于x[0]得到任意时刻t的x[t]&quot;&quot;&quot;</span></span><br><span class="line">    noise = torch.randn_like(x_0)</span><br><span class="line">    alphas_t = alphas_bar_sqrt[t]</span><br><span class="line">    alphas_1_m_t = one_minus_alphas_bar_sqrt[t]</span><br><span class="line">    <span class="keyword">return</span> (alphas_t * x_0 + alphas_1_m_t * noise)<span class="comment">#在x[0]的基础上添加噪声</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 演示原始数据分布加噪100步后的结果</span></span><br><span class="line">num_shows = <span class="number">20</span></span><br><span class="line">fig,axs = plt.subplots(<span class="number">2</span>,<span class="number">10</span>,figsize=(<span class="number">28</span>,<span class="number">3</span>))</span><br><span class="line">plt.rc(<span class="string">&#x27;text&#x27;</span>,color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#共有10000个点，每个点包含两个坐标</span></span><br><span class="line"><span class="comment">#生成100步以内每隔5步加噪声后的图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_shows):</span><br><span class="line">    j = i//<span class="number">10</span></span><br><span class="line">    k = i%<span class="number">10</span></span><br><span class="line">    q_i = q_x(dataset,torch.tensor([i*num_steps//num_shows]))<span class="comment">#生成t时刻的采样数据</span></span><br><span class="line">    axs[j,k].scatter(q_i[:,<span class="number">0</span>],q_i[:,<span class="number">1</span>],color=<span class="string">&#x27;red&#x27;</span>,edgecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    axs[j,k].set_axis_off()</span><br><span class="line">    axs[j,k].set_title(<span class="string">&#x27;$q(\mathbf&#123;x&#125;_&#123;&#x27;</span>+<span class="built_in">str</span>(i*num_steps//num_shows)+<span class="string">&#x27;&#125;)$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写拟合逆扩散过程高斯分布的模型</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLPDiffusion</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_steps, num_units=<span class="number">128</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MLPDiffusion, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.linears = nn.ModuleList(</span><br><span class="line">            [</span><br><span class="line">                nn.Linear(<span class="number">2</span>, num_units),</span><br><span class="line">                nn.ReLU(),</span><br><span class="line">                nn.Linear(num_units, num_units),</span><br><span class="line">                nn.ReLU(),</span><br><span class="line">                nn.Linear(num_units, num_units),</span><br><span class="line">                nn.ReLU(),</span><br><span class="line">                nn.Linear(num_units, <span class="number">2</span>),</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">        self.step_embeddings = nn.ModuleList(</span><br><span class="line">            [</span><br><span class="line">                nn.Embedding(n_steps, num_units),</span><br><span class="line">                nn.Embedding(n_steps, num_units),</span><br><span class="line">                nn.Embedding(n_steps, num_units),</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="comment">#         x = x_0</span></span><br><span class="line">        <span class="keyword">for</span> idx, embedding_layer <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.step_embeddings):</span><br><span class="line">            t_embedding = embedding_layer(t)</span><br><span class="line">            x = self.linears[<span class="number">2</span> * idx](x)</span><br><span class="line">            x += t_embedding</span><br><span class="line">            x = self.linears[<span class="number">2</span> * idx + <span class="number">1</span>](x)</span><br><span class="line"></span><br><span class="line">        x = self.linears[-<span class="number">1</span>](x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写训练的误差函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">diffusion_loss_fn</span>(<span class="params">model, x_0, alphas_bar_sqrt, one_minus_alphas_bar_sqrt, n_steps</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对任意时刻t进行采样计算loss&quot;&quot;&quot;</span></span><br><span class="line">    batch_size = x_0.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对一个batchsize样本生成随机的时刻t</span></span><br><span class="line">    t = torch.randint(<span class="number">0</span>, n_steps, size=(batch_size // <span class="number">2</span>,))</span><br><span class="line">    t = torch.cat([t, n_steps - <span class="number">1</span> - t], dim=<span class="number">0</span>)</span><br><span class="line">    t = t.unsqueeze(-<span class="number">1</span>) <span class="comment">#(batch_size, 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># x0的系数</span></span><br><span class="line">    a = alphas_bar_sqrt[t]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># eps的系数</span></span><br><span class="line">    aml = one_minus_alphas_bar_sqrt[t]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成随机噪音eps</span></span><br><span class="line">    e = torch.randn_like(x_0) <span class="comment"># (batch_size, 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造模型的输入</span></span><br><span class="line">    x = x_0 * a + e * aml</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 送入模型，得到t时刻的随机噪声预测值</span></span><br><span class="line">    output = model(x, t.squeeze(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 与真实噪声一起计算误差，求平均值</span></span><br><span class="line">    <span class="keyword">return</span> (e - output).square().mean()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写逆扩散采样函数（inference）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p_sample_loop</span>(<span class="params">model, shape, n_steps, betas, one_minus_alphas_bar_sqrt</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从x[T]恢复x[T-1]、x[T-2]|...x[0]&quot;&quot;&quot;</span></span><br><span class="line">    cur_x = torch.randn(shape) <span class="comment"># (1000, 2)</span></span><br><span class="line">    x_seq = [cur_x]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(n_steps)):</span><br><span class="line">        cur_x = p_sample(model, cur_x, i, betas, one_minus_alphas_bar_sqrt)</span><br><span class="line">        x_seq.append(cur_x)</span><br><span class="line">    <span class="keyword">return</span> x_seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p_sample</span>(<span class="params">model, x, t, betas, one_minus_alphas_bar_sqrt</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从x[T]采样t时刻的重构值&quot;&quot;&quot;</span></span><br><span class="line">    t = torch.tensor([t])</span><br><span class="line"></span><br><span class="line">    coeff = betas[t] / one_minus_alphas_bar_sqrt[t]</span><br><span class="line"></span><br><span class="line">    eps_theta = model(x, t)</span><br><span class="line"></span><br><span class="line">    mean = (<span class="number">1</span> / (<span class="number">1</span> - betas[t]).sqrt()) * (x - (coeff * eps_theta))</span><br><span class="line"></span><br><span class="line">    z = torch.randn_like(x) <span class="comment"># (1000, 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里用的论文中提到的 betas[t]，也可以用注释部分，但是需要该一下函数，把参数传进来</span></span><br><span class="line"></span><br><span class="line">    sigma_t = betas[t].sqrt()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># sigma_t = betas[t]* (1 - alphas_prod_p[t]) / (1 - alphas_prod[t])</span></span><br><span class="line"></span><br><span class="line">    sample = mean + sigma_t * z</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (sample)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练模型，打印loss及中间重构效果</span></span><br><span class="line">seed = <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个类好像没用到呀！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EMA</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;构建一个参数平滑器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mu=<span class="number">0.01</span></span>):</span><br><span class="line">        self.mu = mu</span><br><span class="line">        self.shadow = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">self, name, val</span>):</span><br><span class="line">        self.shadow[name] = val.clone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, name, x</span>):</span><br><span class="line">        <span class="keyword">assert</span> name <span class="keyword">in</span> self.shadow</span><br><span class="line">        new_average = self.mu * x + (<span class="number">1.0</span> - self.mu) * self.shadow[name]</span><br><span class="line">        self.shadow[name] = new_average.clone()</span><br><span class="line">        <span class="keyword">return</span> new_average</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Training model...&#x27;</span>)</span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">num_epoch = <span class="number">4000</span></span><br><span class="line">plt.rc(<span class="string">&#x27;text&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = MLPDiffusion(num_steps)  <span class="comment"># 输出维度是2，输入是x和step</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    <span class="keyword">for</span> idx, batch_x <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):</span><br><span class="line">        loss = diffusion_loss_fn(model, batch_x, alphas_bar_sqrt, one_minus_alphas_bar_sqrt, num_steps)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        torch.nn.utils.clip_grad_norm_(model.parameters(), <span class="number">1.</span>)</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t % <span class="number">100</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(loss)</span><br><span class="line">        x_seq = p_sample_loop(model, dataset.shape, num_steps, betas, one_minus_alphas_bar_sqrt)</span><br><span class="line"></span><br><span class="line">        fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">10</span>, figsize=(<span class="number">28</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">            cur_x = x_seq[i * <span class="number">10</span>].detach()</span><br><span class="line">            axs[i - <span class="number">1</span>].scatter(cur_x[:, <span class="number">0</span>], cur_x[:, <span class="number">1</span>], color=<span class="string">&#x27;red&#x27;</span>, edgecolor=<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">            axs[i - <span class="number">1</span>].set_axis_off();</span><br><span class="line">            axs[i - <span class="number">1</span>].set_title(<span class="string">&#x27;$q(\mathbf&#123;x&#125;_&#123;&#x27;</span> + <span class="built_in">str</span>(i * <span class="number">10</span>) + <span class="string">&#x27;&#125;)$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动画演示扩散过程和逆扩散过程</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">imgs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    plt.clf()</span><br><span class="line">    q_i = q_x(dataset, torch.tensor([i]))</span><br><span class="line">    plt.scatter(q_i[:, <span class="number">0</span>], q_i[:, <span class="number">1</span>], color=<span class="string">&#x27;red&#x27;</span>, edgecolor=<span class="string">&#x27;white&#x27;</span>, s=<span class="number">5</span>);</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    img_buf = io.BytesIO()</span><br><span class="line">    plt.savefig(img_buf, <span class="built_in">format</span>=<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_buf)</span><br><span class="line">    imgs.append(img)</span><br><span class="line"></span><br><span class="line">reverse = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    plt.clf()</span><br><span class="line">    cur_x = x_seq[i].detach()</span><br><span class="line">    plt.scatter(cur_x[:, <span class="number">0</span>], cur_x[:, <span class="number">1</span>], color=<span class="string">&#x27;red&#x27;</span>, edgecolor=<span class="string">&#x27;white&#x27;</span>, s=<span class="number">5</span>);</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    img_buf = io.BytesIO()</span><br><span class="line">    plt.savefig(img_buf, <span class="built_in">format</span>=<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_buf)</span><br><span class="line">    reverse.append(img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imgs = imgs +reverse</span><br><span class="line">imgs[<span class="number">0</span>].save(<span class="string">&quot;diffusion.gif&quot;</span>,<span class="built_in">format</span>=<span class="string">&#x27;GIF&#x27;</span>,append_images=imgs,save_all=<span class="literal">True</span>,duration=<span class="number">100</span>,loop=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>参考资料</p>
<p><img src="/../images/diffusion_model.webp"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/06/diffusion-model/" data-id="clky8whz20004hcu53vf59ppr" data-title="diffusion_model" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-相机坐标-世界坐标转换" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/22/%E7%9B%B8%E6%9C%BA%E5%9D%90%E6%A0%87-%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time class="dt-published" datetime="2023-02-22T15:02:01.000Z" itemprop="datePublished">2023-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/22/%E7%9B%B8%E6%9C%BA%E5%9D%90%E6%A0%87-%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/">相机坐标_世界坐标转换</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>工程中有些图像处理任务需要真实物理尺寸，本文讲解如何根据图像坐标系与真实物理坐标系之间的对应关系从图像中获取真实物理尺寸。<br>参考：</p>
<ul>
<li>视觉SLAM十四讲</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74597564">https://zhuanlan.zhihu.com/p/74597564</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/localdevices/pyorc">https://github.com/localdevices/pyorc</a></li>
</ul>
<h2 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h2><p>先了解一下常见的几种3D几何变换</p>
<p><img src="/../images/geometric.jpg"><br>单目相机成像模型如下</p>
<p><img src="/../images/camera_model.png"><br>需要经过如下步骤</p>
<p><img src="/../images/coordinates_transformation.png"></p>
<h2 id="几种变换求解"><a href="#几种变换求解" class="headerlink" title="几种变换求解"></a>几种变换求解</h2><p>首先讲清楚需求：给定一个图像，要转换成俯视图视角。</p>
<p>由于3D空间点映射到2D相平面是存在不可逆的信息损失的（基深度方向的信息损失），所以不可能单纯根据一个图像就还原成俯视图视角下的图像（其他视角也不行）。但是如果这些点在同一个平面上，是可以还原成垂直这个平面视角的图像的。</p>
<p>一种思路就是在图像中选取四个点，要求这四个点在俯视图中要是一个矩形框，根据点的对应关系可以得到单应性矩阵，然后根据单应性矩阵得到转换后的图像。</p>
<p>还有一种思路是根据PnP方法求得相机位姿，然后选一个矩形框，根据相机位姿得到对应的像素坐标，然后再根据像素坐标和这个框坐标的对应关系获取单应性矩阵。当然这种思路的意义就是可以从相机获取相机内参及方位角（世界坐标系可以建在以相机为原点的位置，这样及省去了位移），从而即使相机有变动也不用再去现场找矩形框对应的点，但是具体没实践过。</p>
<p>关于怎样通过相机内参及外参，将该视角下的图像转换为另一视角下的图像。具体过程就是先求当前视角转换到另一视角的矩阵，得到当前视角<strong>相机坐标系</strong>上的点映射到另一视角<strong>相机坐标系</strong>上的点的矩阵。通过相机内存矩阵求逆得到当前视角像素坐标系映射到当前视角相机坐标系的矩阵，然后在将当前视角相机坐标系下的点乘以之前求到的视角转换矩阵就得到另一视角相机坐标系下的点，然后乘以相机内参矩阵映射到像素坐标。参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013019296/article/details/119259585">https://blog.csdn.net/u013019296/article/details/119259585</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相机内参矩阵</span></span><br><span class="line">Mat cameraMatrix = (Mat_&lt;double&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">700.0</span>, <span class="number">0.0</span>, <span class="number">320.0</span>,</span><br><span class="line">                       <span class="number">0.0</span>, <span class="number">700.0</span>, <span class="number">240.0</span>,</span><br><span class="line">                       <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment"># 当前视角相机外参</span></span><br><span class="line">Mat R1 = c1Mo(Range(<span class="number">0</span>, <span class="number">3</span>), Range(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment"># 另一视角相机外参</span></span><br><span class="line">Mat R2 = c2Mo(Range(<span class="number">0</span>, <span class="number">3</span>), Range(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line"> //c1Mo * oMc2</span><br><span class="line"><span class="comment">#  当前视角相加坐标系下的点转换到另一视角相机坐标系下的转换矩阵，这里直接转置是求逆与求转置等价</span></span><br><span class="line">Mat R_2to1 = R1*R2.t();//同一平面两个不同相机坐标系的单应矩阵</span><br><span class="line">// [compute-homography]</span><br><span class="line"><span class="comment"># 最后将三者相乘，得到不同视角下的转换矩阵</span></span><br><span class="line">Mat H = cameraMatrix * R_2to1 * cameraMatrix.inv();//同一平面计算出两个图像间的单应矩阵H</span><br><span class="line">H /= H.at&lt;double&gt;(<span class="number">2</span>, <span class="number">2</span>);//归一化</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;H:\n&quot;</span> &lt;&lt; H &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>单应性不严谨的定义：用 [无镜头畸变] 的相机从不同位置拍摄 [同一平面物体] 的图像之间存在单应性，可以用 [透视变换] 表示。可以得到一个直接描述图像坐标变换的矩阵。</li>
<li>对极几何约束：根据两个视角中点的对应关系求解相机运动（旋转+平移）的一种方式</li>
<li>三角测量：在使用对极约束后估算点的深度信息的一种方法。</li>
<li>PnP（Perspective-n-Point）是求解 3D 到 2D 点对运动的方法。它描述了当我们知道 n 个 3D 空间点以及它们的投影位置时，如何估计相机所在的位姿。在双目或 RGB-D 的视觉里程计中，我们可以直接使用 PnP 估计相机运动。而在单目视觉里程计中，必须先进行初始化，然后才能使用 PnP。3D-2D 方法不需要使用对极约束，又可以在很少的匹配点中获得较好的运动估计，是最重要的一种姿态估计方法。</li>
<li>PnP 问题有很多种求解方法，例如用三对点估计位姿的 P3P，直接线性变换（DLT），EPn（Efficient PnP），UPnP 等等）。此外，还能用非线性优化的方式，构建最小二乘问题并迭代求解，也就是万金油式的 Bundle Adjustment。</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>获取图像中点的坐标可以使用以下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line">im = array(Image.<span class="built_in">open</span>(<span class="string">r&quot;water.jpg&quot;</span>))</span><br><span class="line">imshow(im)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Please click 4 points&#x27;</span>)</span><br><span class="line">x =ginput(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;you clicked:&#x27;</span>,x)</span><br><span class="line">show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就可以获取单应性矩阵，并根据单应性矩阵得到俯视图了（特别注意：为了获取俯视图，要求进行映射的四个点在俯视视图中是一个矩形，因为就是将这四个点映射到俯视视图指定像素上，这样才方便具体实践）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">r&quot;water.jpg&quot;</span>)</span><br><span class="line">w, h, _ = img.shape</span><br><span class="line"></span><br><span class="line">width,height = <span class="number">250</span>,<span class="number">350</span>  <span class="comment">#所需图像大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#所需图像部分四个顶点的像素点坐标</span></span><br><span class="line">pts1 = np.float32([[<span class="number">658</span>, <span class="number">227</span>],[<span class="number">943</span>, <span class="number">286</span>],[<span class="number">516</span>, <span class="number">527</span>],[<span class="number">837</span>, <span class="number">597</span>]])  <span class="comment">#所需图像部分四个顶点的像素点坐标</span></span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>+<span class="number">100</span>,<span class="number">0</span>+<span class="number">100</span>],[<span class="number">0.2</span>*width+<span class="number">100</span>,<span class="number">0</span>+<span class="number">100</span>],[<span class="number">0</span>+<span class="number">100</span>,<span class="number">0.2</span>*height+<span class="number">100</span>],[<span class="number">0.2</span>*width+<span class="number">100</span>,<span class="number">0.2</span>*height+<span class="number">100</span>]]) <span class="comment">#定义对应的像素点坐标(特别注意这里是找的四个点映射到俯视图后的坐标)</span></span><br><span class="line">matrix_K = cv2.getPerspectiveTransform(pts1,pts2)  <span class="comment">#使用getPerspectiveTransform()得到转换矩阵</span></span><br><span class="line"><span class="built_in">print</span>(matrix_K)</span><br><span class="line">img_K = cv2.warpPerspective(img,matrix_K,(width,height))  <span class="comment">#使用warpPerspective()进行透视变换</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;Original Image&quot;</span>,img)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img K&quot;</span>,img_K)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码只是一种理想情况，也就是需要找到水面上一个矩形框，知道矩形框实际大小，水位在变化，找一个理想的矩形框也很难。可不可以只找某一平面的四个点的坐标，然后水位变化也可以呢，以下代码可以解决此工程问题，参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon, LineString</span><br><span class="line"><span class="keyword">from</span> shapely.affinity <span class="keyword">import</span> rotate</span><br><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gcp_mean</span>(<span class="params">dst</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array(dst).mean(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从定义的四个感兴趣的点生成矩形 bbox</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_bbox_from_corners</span>(<span class="params">corners, resolution, dst</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Establish bbox based on a set of camera perspective corner points Assign corner coordinates to camera</span></span><br><span class="line"><span class="string">    configuration</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    corners : list of lists (4)</span></span><br><span class="line"><span class="string">        [columns, row] coordinates in camera perspective</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> (np.array(corners).shape == (<span class="number">4</span>,</span><br><span class="line">                                        <span class="number">2</span>)), <span class="string">f&quot;a list of lists of 4 coordinates must be given, resulting in (4, &quot;</span> \</span><br><span class="line">                                             <span class="string">f&quot;2) shape. Current shape is <span class="subst">&#123;corners.shape&#125;</span> &quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get homography, this is the only place besides self.get_M where cv.get_M is used.</span></span><br><span class="line">    M_gcp = get_M()</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> make derivation dependent on 3D or 2D point availability</span></span><br><span class="line">    <span class="comment"># if self.gcps[&quot;src&quot;].shape == 3:</span></span><br><span class="line">    <span class="comment">#     # <span class="doctag">TODO:</span> homography from solvepnp</span></span><br><span class="line">    bbox = get_aoi(M_gcp, corners, resolution=<span class="number">0.05</span>)</span><br><span class="line">    <span class="comment"># bbox is offset by self.gcp_mean. Regenerate bbox after adding offset</span></span><br><span class="line">    bbox_xy = np.array(bbox.exterior.coords)</span><br><span class="line">    <span class="comment"># 在计算get_M()的时候减去了gcp_mean，所以现在要加gcp_mean</span></span><br><span class="line">    gcp_mean = np.array(dst).mean(axis=<span class="number">0</span>)</span><br><span class="line">    bbox_xy += gcp_mean[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    bbox = Polygon(bbox_xy)</span><br><span class="line">    <span class="keyword">return</span> bbox, bbox_xy[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据像素坐标系中感兴趣的点和单应性矩阵得到矩形框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_aoi</span>(<span class="params">M, src_corners, resolution=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get rectangular AOI from 4 user defined points within frames.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    src : list of tuples</span></span><br><span class="line"><span class="string">        (col, row) pairs of ground control points</span></span><br><span class="line"><span class="string">    dst : list of tuples</span></span><br><span class="line"><span class="string">        projected (x, y) coordinates of ground control points</span></span><br><span class="line"><span class="string">    src_corners : dict with 4 (x,y) tuples</span></span><br><span class="line"><span class="string">        names &quot;up_left&quot;, &quot;down_left&quot;, &quot;up_right&quot;, &quot;down_right&quot;, source corners</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    aoi : shapely.geometry.Polygon</span></span><br><span class="line"><span class="string">        bounding box of aoi (rotated)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># retrieve the M transformation matrix for the conditions during GCP. These are used to define the AOI so that</span></span><br><span class="line">    <span class="comment"># dst AOI remains the same for any movie</span></span><br><span class="line">    <span class="comment"># prepare a simple temporary np.array of the src_corners</span></span><br><span class="line">    _src_corners = np.array(src_corners)</span><br><span class="line">    <span class="keyword">assert</span>(_src_corners.shape==(<span class="number">4</span>, <span class="number">2</span>)), <span class="string">f&quot;a list of lists of 4 coordinates must be given, resulting in (4, 2) shape. &quot;</span> \</span><br><span class="line">                                        <span class="string">f&quot;Current shape is <span class="subst">&#123;src_corners.shape&#125;</span> &quot;</span></span><br><span class="line">    <span class="comment"># reproject corner points to the actual space in coordinates</span></span><br><span class="line">    _dst_corners = cv2.perspectiveTransform(np.float32([_src_corners]), M)[<span class="number">0</span>]</span><br><span class="line">    polygon = Polygon(_dst_corners)</span><br><span class="line">    coords = np.array(polygon.exterior.coords)</span><br><span class="line">    <span class="comment"># estimate the angle of the bounding box</span></span><br><span class="line">    <span class="comment"># retrieve average line across AOI</span></span><br><span class="line">    point1 = (coords[<span class="number">0</span>] + coords[<span class="number">3</span>]) / <span class="number">2</span></span><br><span class="line">    point2 = (coords[<span class="number">1</span>] + coords[<span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line">    diff = point2 - point1</span><br><span class="line">    angle = np.arctan2(diff[<span class="number">1</span>], diff[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># rotate the polygon over this angle to get a proper bounding box</span></span><br><span class="line">    polygon_rotate = rotate(</span><br><span class="line">        polygon, -angle, origin=<span class="built_in">tuple</span>(_dst_corners[<span class="number">0</span>]), use_radians=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    xmin, ymin, xmax, ymax = polygon_rotate.bounds</span><br><span class="line">    <span class="keyword">if</span> resolution <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        xmin = round_to_multiple(xmin, resolution)</span><br><span class="line">        xmax = round_to_multiple(xmax, resolution)</span><br><span class="line">        ymin = round_to_multiple(ymin, resolution)</span><br><span class="line">        ymax = round_to_multiple(ymax, resolution)</span><br><span class="line">    <span class="comment"># 这个地方返回的就是一个矩形框了</span></span><br><span class="line">    bbox_coords = [(xmin, ymax), (xmax, ymax), (xmax, ymin), (xmin, ymin), (xmin, ymax)]</span><br><span class="line">    bbox = Polygon(bbox_coords)</span><br><span class="line">    <span class="comment"># now rotate back</span></span><br><span class="line">    bbox = rotate(bbox, angle, origin=<span class="built_in">tuple</span>(_dst_corners[<span class="number">0</span>]), use_radians=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> bbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">round_to_multiple</span>(<span class="params">number, multiple</span>):</span><br><span class="line">    <span class="keyword">return</span> multiple * <span class="built_in">round</span>(number / multiple)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bbox</span>(<span class="params">bbox, dst, camera=<span class="literal">False</span>, h_a=<span class="literal">None</span>, redistort=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    camera : bool, optional</span></span><br><span class="line"><span class="string">        If set, the bounding box will be returned as row and column coordinates in the camera perspective.</span></span><br><span class="line"><span class="string">        In this case ``h_a`` may be set to provide the right water level, to estimate the bounding box for.</span></span><br><span class="line"><span class="string">    h_a : float, optional</span></span><br><span class="line"><span class="string">        If set with ``camera=True``, then the bbox coordinates will be transformed to the camera perspective,</span></span><br><span class="line"><span class="string">        using h_a as a present water level. In case a video with higher (lower) water levels is used, this</span></span><br><span class="line"><span class="string">        will result in a different perspective plane than the control video.</span></span><br><span class="line"><span class="string">    redistort : bool, optional</span></span><br><span class="line"><span class="string">        If set in combination with ``camera``, the bbox will be redistorted in the camera objective using the</span></span><br><span class="line"><span class="string">        distortion coefficients and camera matrix. Not used in orthorectification because this occurs by default</span></span><br><span class="line"><span class="string">        on already undistorted images.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    A bounding box, that in the used CRS is perfectly rectangular, and aligned in the up/downstream direction.</span></span><br><span class="line"><span class="string">    It can (and certainly will) be rotated with respect to a typical bbox with xlim, ylim coordinates.</span></span><br><span class="line"><span class="string">    If user sets ``camera=True`` then the geographical bounding box will be converted into a camera perspective,</span></span><br><span class="line"><span class="string">    using the homography belonging to the available ground control points and current water level.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This can then be used to reconstruct the grid for velocimetry calculations.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    bbox = bbox</span><br><span class="line">    <span class="keyword">if</span> camera:</span><br><span class="line">        coords = np.array(bbox.exterior.coords)</span><br><span class="line">        <span class="comment"># convert to perspective rowcol coordinates</span></span><br><span class="line">        M = get_M(reverse=<span class="literal">True</span>, h_a=h_a)</span><br><span class="line">        <span class="comment"># reduce coords by control point mean</span></span><br><span class="line">        gcp_mean = np.array(dst).mean(axis=<span class="number">0</span>)</span><br><span class="line">        coords -= gcp_mean[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> re-distort if needed</span></span><br><span class="line">        corners = cv2.perspectiveTransform(np.float32([coords]), M)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># if redistort:</span></span><br><span class="line">        <span class="comment">#     # for visualization on still distorted frames this can be done. DO NOT do this if used for</span></span><br><span class="line">        <span class="comment">#     # orthorectification, as this typically occurs on undistorted images.</span></span><br><span class="line">        <span class="comment">#     corners = cv.undistort_points(corners, self.camera_matrix, self.dist_coeffs, reverse=True)</span></span><br><span class="line"></span><br><span class="line">        bbox = Polygon(corners)</span><br><span class="line">    <span class="keyword">return</span> bbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_M</span>(<span class="params">h_a=<span class="literal">None</span>, to_bbox_grid=<span class="literal">False</span>, reverse=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Establish a transformation matrix for a certain actual water level `h_a`. This is done by mapping where the</span></span><br><span class="line"><span class="string">    ground control points, measured at `h_ref` will end up with new water level `h_a`, given the lens position.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    h_a : float, optional</span></span><br><span class="line"><span class="string">        actual water level [m] (Default: None)</span></span><br><span class="line"><span class="string">    to_bbox_grid : bool, optional</span></span><br><span class="line"><span class="string">        if set, the M will be computed in row, column values of the target bbox, with set resolution</span></span><br><span class="line"><span class="string">    reverse : bool, optional</span></span><br><span class="line"><span class="string">        if True, the reverse matrix is prepared, which can be used to transform projected</span></span><br><span class="line"><span class="string">        coordinates back to the original camera perspective. (Default: False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    M : np.ndarray</span></span><br><span class="line"><span class="string">        2x3 transformation matrix</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># src = cv.undistort_points(self.gcps[&quot;src&quot;], self.camera_matrix, self.dist_coeffs)</span></span><br><span class="line">    <span class="comment"># print(&quot;origin src self.gcps: &quot;, self.gcps[&quot;src&quot;])</span></span><br><span class="line">    <span class="comment"># print(&quot;get_m src:&quot;,src)</span></span><br><span class="line">    <span class="keyword">if</span> to_bbox_grid:</span><br><span class="line">        <span class="comment"># lookup where the destination points are in row/column space</span></span><br><span class="line">        <span class="comment"># dst_a is the destination point locations position with the actual water level</span></span><br><span class="line">        dst_a = transform_to_bbox(</span><br><span class="line">            get_dst_a(h_a),</span><br><span class="line">            bbox,</span><br><span class="line">            resolution</span><br><span class="line">        )</span><br><span class="line">        dst_a = np.array(dst_a)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># in case we are dealing with a 2D 4-point, then reproject points on water surface, else keep 3D points</span></span><br><span class="line">        <span class="comment"># 将参考平面四个点映射到水面</span></span><br><span class="line">        dst_a = get_dst_a(h_a) <span class="keyword">if</span> gcp_dims == <span class="number">2</span> <span class="keyword">else</span> dst</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reduce dst_a with its mean to get much more accurate projection result in case x and y order of</span></span><br><span class="line">        <span class="comment"># magnitude is very large</span></span><br><span class="line">        gcp_mean = np.array(dst).mean(axis=<span class="number">0</span>)</span><br><span class="line">        dst_a -= gcp_mean</span><br><span class="line">    <span class="comment"># src_a = self.get_src(**lens_pars)</span></span><br><span class="line">    <span class="keyword">if</span> dst_a.shape[-<span class="number">1</span>] == <span class="number">3</span>:</span><br><span class="line">        <span class="comment"># compute the water level in the coordinate system reduced with the mean gcp coordinate</span></span><br><span class="line">        z_a = get_z_a(h_a)</span><br><span class="line">        gcp_mean = np.array(dst).mean(axis=<span class="number">0</span>)</span><br><span class="line">        z_a -= gcp_mean[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># treating 3D homography</span></span><br><span class="line">        <span class="keyword">return</span> get_M_3D(</span><br><span class="line">            src=src,</span><br><span class="line">            dst=dst_a,</span><br><span class="line">            camera_matrix=camera_matrix,</span><br><span class="line">            dist_coeffs=dist_coeffs,</span><br><span class="line">            z=z_a,</span><br><span class="line">            reverse=reverse</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> get_M_2D(</span><br><span class="line">            src=src,</span><br><span class="line">            dst=dst_a,</span><br><span class="line">            reverse=reverse</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据四个对应的2D坐标点得到单应性矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_M_2D</span>(<span class="params">src, dst, reverse=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Retrieve homography matrix for between (4) src and (4) dst points with only x, y coordinates (no z)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    src : list of lists</span></span><br><span class="line"><span class="string">        [x, y] with source coordinates, typically cols and rows in image</span></span><br><span class="line"><span class="string">    dst : list of lists</span></span><br><span class="line"><span class="string">        [x, y] with target coordinates after reprojection, can e.g. be in crs [m]</span></span><br><span class="line"><span class="string">    reverse : bool, optional</span></span><br><span class="line"><span class="string">        If set, the reverse homography to back-project to camera objective will be retrieved</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    M : np.ndarray</span></span><br><span class="line"><span class="string">        homography matrix (3x3), used in cv2.warpPerspective</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># set points to float32</span></span><br><span class="line">    _src = np.float32(src)</span><br><span class="line">    _dst = np.float32(dst)</span><br><span class="line">    <span class="comment"># define transformation matrix based on GCPs</span></span><br><span class="line">    <span class="keyword">if</span> reverse:</span><br><span class="line">        M = cv2.getPerspectiveTransform(_dst, _src)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        M = cv2.getPerspectiveTransform(_src, _dst)</span><br><span class="line">    <span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先得到相机外参（需要内参已知），于是就得到了像素到世界坐标（要求的俯视平面为x-y平面，z=0）的映射矩阵，而我们要求的单应矩阵其实就是这样的一个映射</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_M_3D</span>(<span class="params">src, dst, camera_matrix, dist_coeffs=np.zeros(<span class="params">(<span class="params"><span class="number">1</span>, <span class="number">4</span></span>)</span>), z=<span class="number">0.</span>, reverse=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Retrieve homography matrix for between (6+) 2D src and (6+) 3D dst (x, y, z) points</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    src : list of lists</span></span><br><span class="line"><span class="string">        [x, y] with source coordinates, typically cols and rows in image</span></span><br><span class="line"><span class="string">    dst : list of lists</span></span><br><span class="line"><span class="string">        [x, y, z] with target coordinates after reprojection, can e.g. be in crs [m]</span></span><br><span class="line"><span class="string">    camera_matrix : np.ndarray (3x3)</span></span><br><span class="line"><span class="string">        Camera intrinsic matrix</span></span><br><span class="line"><span class="string">    dist_coeffs : p.ndarray, optional</span></span><br><span class="line"><span class="string">        1xN array with distortion coefficients (N = 4, 5 or 8)</span></span><br><span class="line"><span class="string">    z : float, optional</span></span><br><span class="line"><span class="string">        Elevation plane (real-world coordinate crs) of projected image</span></span><br><span class="line"><span class="string">    reverse : bool, optional</span></span><br><span class="line"><span class="string">        If set, the reverse homography to back-project to camera objective will be retrieved</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    M : np.ndarray</span></span><br><span class="line"><span class="string">        homography matrix (3x3), used in cv2.warpPerspective</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    See rectification workflow OpenCV</span></span><br><span class="line"><span class="string">    http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html</span></span><br><span class="line"><span class="string">    Code based on:</span></span><br><span class="line"><span class="string">    https://www.openearth.nl/flamingo/_modules/flamingo/rectification/rectification.html</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># set points to float32</span></span><br><span class="line">    _src = np.float32(src)</span><br><span class="line">    _dst = np.float32(dst)</span><br><span class="line">    <span class="comment"># import pdb;pdb.set_trace()</span></span><br><span class="line">    camera_matrix = np.float32(camera_matrix)</span><br><span class="line">    dist_coeffs = np.float32(dist_coeffs)</span><br><span class="line">    <span class="comment"># define transformation matrix based on GCPs</span></span><br><span class="line">    success, rvec, tvec = cv2.solvePnP(_dst, _src, camera_matrix, dist_coeffs)</span><br><span class="line">    <span class="comment"># convert rotation vector to rotation matrix</span></span><br><span class="line">    R = cv2.Rodrigues(rvec)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># assume height of projection plane</span></span><br><span class="line">    R[:, <span class="number">2</span>] = R[:, <span class="number">2</span>] * z</span><br><span class="line">    <span class="comment"># add translation vector</span></span><br><span class="line">    R[:, <span class="number">2</span>] = R[:, <span class="number">2</span>] + tvec.flatten()</span><br><span class="line">    <span class="comment"># compute homography</span></span><br><span class="line">    <span class="keyword">if</span> reverse:</span><br><span class="line">        <span class="comment"># From perspective to objective</span></span><br><span class="line">        M = np.dot(camera_matrix, R)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># from objective to perspective</span></span><br><span class="line">        M = np.linalg.inv(np.dot(camera_matrix, R))</span><br><span class="line">    <span class="comment"># normalize homography before returning</span></span><br><span class="line">    <span class="keyword">return</span> M / M[-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform_to_bbox</span>(<span class="params">coords, bbox, resolution</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;transforms a set of coordinates defined in crs of bbox, into a set of coordinates in cv2 compatible pixels</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    coords : list of lists</span></span><br><span class="line"><span class="string">        [x, y] with coordinates</span></span><br><span class="line"><span class="string">    bbox : shapely Polygon</span></span><br><span class="line"><span class="string">        Bounding box. The coordinate order is very important and has to be upstream-left, downstream-left,</span></span><br><span class="line"><span class="string">        downstream-right, upstream-right, upstream-left</span></span><br><span class="line"><span class="string">    resolution : float</span></span><br><span class="line"><span class="string">        resolution of target pixels within bbox</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    colrows : list</span></span><br><span class="line"><span class="string">        tuples of columns and rows</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># first assemble x and y coordinates</span></span><br><span class="line">    xs, ys = <span class="built_in">zip</span>(*coords)</span><br><span class="line">    transform = _get_transform(bbox, resolution)</span><br><span class="line">    rows, cols = rasterio.transform.rowcol(transform, xs, ys, op=<span class="built_in">float</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(cols, rows))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_transform</span>(<span class="params">bbox, resolution=<span class="number">0.01</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a rotated Affine transformation that fits with the bounding box and resolution.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    bbox : shapely.geometry.Polygon</span></span><br><span class="line"><span class="string">        polygon of bounding box. The coordinate order is very important and has to be:</span></span><br><span class="line"><span class="string">        (upstream-left, downstream-left, downstream-right, upstream-right, upstream-left)</span></span><br><span class="line"><span class="string">    resolution : float, optional</span></span><br><span class="line"><span class="string">        resolution of target grid in meters (default: 0.01)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    affine : rasterio.transform.Affine</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    corners = np.array(bbox.exterior.coords)</span><br><span class="line">    <span class="comment"># estimate the angle of the bounding box</span></span><br><span class="line">    top_left_x, top_left_y = corners[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># retrieve average line across AOI</span></span><br><span class="line">    point1 = corners[<span class="number">0</span>]</span><br><span class="line">    point2 = corners[<span class="number">1</span>]</span><br><span class="line">    diff = point2 - point1</span><br><span class="line">    <span class="comment"># compute the angle of the projected bbox area of interest</span></span><br><span class="line">    angle = np.arctan2(diff[<span class="number">1</span>], diff[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># compute per col the x and y diff</span></span><br><span class="line">    dx_col, dy_col = np.cos(angle) * resolution, np.sin(angle) * resolution</span><br><span class="line">    <span class="comment"># compute per row the x and y offsets</span></span><br><span class="line">    dx_row, dy_row = (</span><br><span class="line">        np.cos(angle + <span class="number">1.5</span> * np.pi) * resolution,</span><br><span class="line">        np.sin(angle + <span class="number">1.5</span> * np.pi) * resolution,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> rasterio.transform.Affine(</span><br><span class="line">        dx_col, dy_col, top_left_x, dx_row, dy_row, top_left_y</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将参考平面四个点映射到水面</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_dst_a</span>(<span class="params">h_a=<span class="number">0.0</span>, h_ref=<span class="number">0.0</span>, lens_position=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    h_a : float, optional</span></span><br><span class="line"><span class="string">        actual water level measured [m], if not set, assumption is that a single video</span></span><br><span class="line"><span class="string">        is processed and thus changes in water level are not relevant. (default: None)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    Actual locations of control points (in case these are only x, y) given the current set water level and</span></span><br><span class="line"><span class="string">    the camera location</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># map where the destination points are with the actual water level h_a.</span></span><br><span class="line">    <span class="keyword">if</span> h_a <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> h_a == h_ref:</span><br><span class="line">        <span class="comment"># fill in the same value for h_ref and h_a</span></span><br><span class="line">        dst_a = dst</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        h_ref = h_ref</span><br><span class="line">        lens_position = lens_position</span><br><span class="line">        dst_a = _get_gcps_a(</span><br><span class="line">            lens_position,</span><br><span class="line">            h_a,</span><br><span class="line">            dst,</span><br><span class="line">            z_0,</span><br><span class="line">            h_ref,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> dst_a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据三角形的相似原理计算真实水面四个点的位置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_gcps_a</span>(<span class="params">lensPosition, h_a, coords, z_0=<span class="number">0.0</span>, h_ref=<span class="number">0.0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the actual x, y locations of ground control points at the actual water level</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    lensPosition : list of floats</span></span><br><span class="line"><span class="string">        x, y, z location of cam in local crs [m]</span></span><br><span class="line"><span class="string">    h_a : float</span></span><br><span class="line"><span class="string">        actual water level in local level measuring system [m]</span></span><br><span class="line"><span class="string">    coords : list of lists</span></span><br><span class="line"><span class="string">        gcp coordinates  [x, y] in original water level</span></span><br><span class="line"><span class="string">    z_0 : float, optional</span></span><br><span class="line"><span class="string">        reference zero plain level, i.e. the crs amount of meters of the zero level of staff gauge (default: 0.0)</span></span><br><span class="line"><span class="string">    h_ref : float, optional</span></span><br><span class="line"><span class="string">        reference water level during taking of gcp coords with ref to staff gauge zero level (default: 0.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    coords : list</span></span><br><span class="line"><span class="string">        rows/cols for use in getPerspectivetransform</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># get modified gcps based on camera location and elevation values</span></span><br><span class="line">    cam_x, cam_y, cam_z = lensPosition</span><br><span class="line">    x, y = <span class="built_in">zip</span>(*coords)</span><br><span class="line">    <span class="comment"># compute the z during gcp coordinates</span></span><br><span class="line">    z_ref = h_ref + z_0</span><br><span class="line">    <span class="comment"># compute z during current frame</span></span><br><span class="line">    z_a = z_0 + h_a</span><br><span class="line">    <span class="comment"># compute the water table to camera height difference during field referencing</span></span><br><span class="line">    cam_height_ref = cam_z - z_ref</span><br><span class="line">    <span class="comment"># compute the actual water table to camera height difference</span></span><br><span class="line">    cam_height_a = cam_z - z_a</span><br><span class="line">    rel_diff = cam_height_a / cam_height_ref</span><br><span class="line">    <span class="comment"># apply the diff on all coordinate, both x, and y directions</span></span><br><span class="line">    _dest_x = <span class="built_in">list</span>(cam_x + (np.array(x) - cam_x) * rel_diff)</span><br><span class="line">    _dest_y = <span class="built_in">list</span>(cam_y + (np.array(y) - cam_y) * rel_diff)</span><br><span class="line">    dest_out = <span class="built_in">list</span>(<span class="built_in">zip</span>(_dest_x, _dest_y))</span><br><span class="line">    <span class="keyword">return</span> dest_out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_z_a</span>(<span class="params">h_a=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    h_a : float, optional</span></span><br><span class="line"><span class="string">        actual water level measured [m], if not set, assumption is that a single video</span></span><br><span class="line"><span class="string">        is processed and thus changes in water level are not relevant. (default: None)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    Actual locations of control points (in case these are only x, y) given the current set water level and</span></span><br><span class="line"><span class="string">    the camera location</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> h_a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> z_0</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z_0 + (h_a - h_ref)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shape</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns rows and columns in projected frames from ``Frames.project``</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    rows : int</span></span><br><span class="line"><span class="string">        Amount of rows in projected frame</span></span><br><span class="line"><span class="string">    cols : int</span></span><br><span class="line"><span class="string">        Amount of columns in projected frame</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cols, rows = _get_shape(</span><br><span class="line">        bbox,</span><br><span class="line">        resolution=resolution,</span><br><span class="line">        <span class="built_in">round</span>=<span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> rows, cols</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_shape</span>(<span class="params">bbox, resolution=<span class="number">0.01</span>, <span class="built_in">round</span>=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    defines the number of rows and columns needed in a target raster, to fit a given bounding box.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param bbox: shapely Polygon, bounding box</span></span><br><span class="line"><span class="string">    :param resolution: resolution of target raster</span></span><br><span class="line"><span class="string">    :param round: number of pixels to round intended shape to</span></span><br><span class="line"><span class="string">    :return: numbers of rows and columns for target raster</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    coords = bbox.exterior.coords</span><br><span class="line">    box_length = LineString(coords[<span class="number">0</span>:<span class="number">2</span>]).length</span><br><span class="line">    box_width = LineString(coords[<span class="number">1</span>:<span class="number">3</span>]).length</span><br><span class="line">    cols = <span class="built_in">int</span>(np.ceil((box_length / resolution) / <span class="built_in">round</span>)) * <span class="built_in">round</span></span><br><span class="line">    rows = <span class="built_in">int</span>(np.ceil((box_width / resolution) / <span class="built_in">round</span>)) * <span class="built_in">round</span></span><br><span class="line">    <span class="keyword">return</span> cols, rows</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 需要4个对应的像素坐标点和真实物理坐标系点</span></span><br><span class="line">    src=[</span><br><span class="line">        [<span class="number">1421</span>, <span class="number">1001</span>],</span><br><span class="line">        [<span class="number">1251</span>, <span class="number">460</span>],</span><br><span class="line">        [<span class="number">421</span>, <span class="number">432</span>],</span><br><span class="line">        [<span class="number">470</span>, <span class="number">607</span>]</span><br><span class="line">    ]</span><br><span class="line">    dst=[</span><br><span class="line">        [<span class="number">642735.8076</span>, <span class="number">8304292.1190</span>],  <span class="comment"># lowest right coordinate</span></span><br><span class="line">        [<span class="number">642737.5823</span>, <span class="number">8304295.593</span>],  <span class="comment"># highest right coordinate</span></span><br><span class="line">        [<span class="number">642732.7864</span>, <span class="number">8304298.4250</span>],  <span class="comment"># highest left coordinate</span></span><br><span class="line">        [<span class="number">642732.6705</span>, <span class="number">8304296.8580</span>]  <span class="comment"># highest right coordinate</span></span><br><span class="line">    ]</span><br><span class="line">    corners = [</span><br><span class="line">        [<span class="number">292</span>, <span class="number">817</span>],</span><br><span class="line">        [<span class="number">50</span>, <span class="number">166</span>],</span><br><span class="line">        [<span class="number">1200</span>, <span class="number">236</span>],</span><br><span class="line">        [<span class="number">1600</span>, <span class="number">834</span>]</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 转换为俯视图每个像素对应的距离，单位为m</span></span><br><span class="line">    resolution = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># 参考点的高度</span></span><br><span class="line">    h_ref = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 水面的高度</span></span><br><span class="line">    h_a = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 摄像头在世界坐标系下的位置</span></span><br><span class="line">    lens_position = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 基准海拔</span></span><br><span class="line">    z_0 = <span class="number">1182.2</span></span><br><span class="line">    gcp_dims = <span class="number">2</span></span><br><span class="line">    camera_matrix = <span class="literal">None</span></span><br><span class="line">    dist_coeffs = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    flags = cv2.INTER_AREA</span><br><span class="line">    <span class="comment"># 根据corners在世界坐标系上求得一个适度的矩形框</span></span><br><span class="line">    bbox, bbox_xy = set_bbox_from_corners(corners, resolution, dst)</span><br><span class="line">    <span class="comment"># 将这个矩形区域映射到像素坐标系下</span></span><br><span class="line">    src_v2 = get_bbox(bbox, dst, camera=<span class="literal">True</span>, h_a=<span class="number">0.0</span>).exterior.coords[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">    <span class="comment"># 获取要映射的dst地址大小，最简单的方式就是直接设置成 [[0,0],[width,0],[0,height],[width,height]]</span></span><br><span class="line">    <span class="comment"># 这里作者为了实现一个像素对应0.01m，特意设置了一个坐标</span></span><br><span class="line">    <span class="comment"># 注意，以上能够实现视角转换全得益于矩形框在世界坐标系下是矩形框</span></span><br><span class="line">    dst_xy = bbox_xy</span><br><span class="line">    dst_v2 = transform_to_bbox(dst_xy, bbox, resolution)</span><br><span class="line">    <span class="comment"># 得到转换矩阵</span></span><br><span class="line">    M = get_M_2D(src_v2, dst_v2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用转换矩阵得到俯视图</span></span><br><span class="line">    <span class="comment"># img = cv2.imread(&#x27;ng_test.png&#x27;)</span></span><br><span class="line">    video_path = <span class="string">r&#x27;ngwerere_20191103.mp4&#x27;</span></span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    frame_list = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">            frame_list.append(frame)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    shape = shape()</span><br><span class="line">    img1 = frame_list[<span class="number">0</span>]</span><br><span class="line">    img2 = frame_list[<span class="number">1</span>]</span><br><span class="line">    final_frame1 = cv2.warpPerspective(img1, M, shape, flags=flags)</span><br><span class="line">    final_frame2 = cv2.warpPerspective(img2, M, shape, flags=flags)</span><br><span class="line">    cv2.imwrite(<span class="string">&quot;transfer_ng1v2_1.png&quot;</span>, final_frame1)</span><br><span class="line">    cv2.imwrite(<span class="string">&quot;transfer_ng2v2_2.png&quot;</span>, final_frame2)</span><br></pre></td></tr></table></figure>

<p>在得到俯视图后就可以进一步求解面积，速度等变量了。<br>根据水纹求解速度有两类方法，一类为 Space-time image velocimetry(stiv)，根据波纹得到纹理图，然后再根据纹理角得到速度。<br>另一类为Particle Image Velocimetry(piv)家族基于图像测流速方法，也是从水面中找特殊描述子然后进行追踪。<br>以下代码为stiv部分实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> m3u8</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> eventlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_alpha_confidence</span>(<span class="params">img, window = <span class="number">3</span></span>):</span><br><span class="line">    length = <span class="built_in">min</span>(img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>])</span><br><span class="line">    length = length <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> length -<span class="number">1</span></span><br><span class="line">    img = img[<span class="number">0</span>:length, <span class="number">0</span>:length]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算水平方向边缘信息</span></span><br><span class="line">    scharrx = cv2.Scharr(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#计算垂直方向边缘信息</span></span><br><span class="line">    scharry = cv2.Scharr(img,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    step = <span class="built_in">int</span>(length / window)</span><br><span class="line"></span><br><span class="line">    alpha_list = []</span><br><span class="line">    c_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(window):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(window):</span><br><span class="line">            Gxx = np.<span class="built_in">sum</span>(scharrx[i*step: (i+<span class="number">1</span>)*step, j*step: (j+<span class="number">1</span>)*step] * scharrx[i*step: (i+<span class="number">1</span>)*step, j*step: (j+<span class="number">1</span>)*step])</span><br><span class="line">            Gxy = np.<span class="built_in">sum</span>(scharrx[i*step: (i+<span class="number">1</span>)*step, j*step: (j+<span class="number">1</span>)*step] * scharry[i*step: (i+<span class="number">1</span>)*step, j*step: (j+<span class="number">1</span>)*step])</span><br><span class="line">            Gyy = np.<span class="built_in">sum</span>(scharry[i*step: (i+<span class="number">1</span>)*step, j*step: (j+<span class="number">1</span>)*step] * scharry[i*step: (i+<span class="number">1</span>)*step, j*step: (j+<span class="number">1</span>)*step])</span><br><span class="line">            <span class="comment"># print((2 * Gxy) / (Gyy - Gxx))</span></span><br><span class="line">            alpha = (math.atan((<span class="number">2</span> * Gxy) / (Gyy - Gxx)) / <span class="number">2</span>) * <span class="number">180</span> / math.pi</span><br><span class="line">            <span class="keyword">if</span> alpha &lt; <span class="number">0</span>:</span><br><span class="line">                alpha = <span class="number">90</span> + alpha</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算清晰置信度</span></span><br><span class="line">            c = math.sqrt((Gxx - Gyy) ** <span class="number">2</span> + <span class="number">4</span> * (Gxy ** <span class="number">2</span>)) / (Gxx + Gyy)</span><br><span class="line">            alpha_list.append(alpha)</span><br><span class="line">            c_list.append(c)</span><br><span class="line"></span><br><span class="line">    f_alpha = <span class="number">0</span></span><br><span class="line">    c_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alpha_list)):</span><br><span class="line">        f_alpha = f_alpha + alpha_list[i] * c_list[i]</span><br><span class="line">        c_sum = c_sum + c_list[i]</span><br><span class="line">    <span class="built_in">print</span>(alpha_list)</span><br><span class="line">    <span class="built_in">print</span>(c_list)</span><br><span class="line">    f_alpha = f_alpha / c_sum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f_alpha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeout</span>(<span class="params">_time</span>):</span><br><span class="line">    <span class="keyword">with</span> eventlet.Timeout(_time, <span class="literal">False</span>):  <span class="comment"># 设置超时间</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;不好意思函数调用超时&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_xt_img</span>(<span class="params">url, max_count=<span class="number">15</span>, frames=<span class="number">200</span>, width_start=<span class="number">267</span>, width_end=<span class="number">350</span>, height_start=<span class="number">334</span></span>):</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    time_cur = <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d-%H-%M-%S&#x27;</span>))</span><br><span class="line">    check = []</span><br><span class="line"></span><br><span class="line">    img_path = os.path.join(<span class="string">&quot;path-to-save&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(img_path):</span><br><span class="line">        os.makedirs(img_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># video_path = img_path + &quot;\\&quot; + &#x27;stiv_post_ljx_online.mp4&#x27;</span></span><br><span class="line">    video_path = <span class="string">&quot;path-to-video&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(video_path):</span><br><span class="line">        <span class="comment"># 删除文件</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            os.remove(video_path)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> r:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;delete online.mp4 wrong &#123;&#125;&quot;</span>.<span class="built_in">format</span>(r))</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; max_count:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;check: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(check))</span><br><span class="line">            playlist = m3u8.load(uri=url, headers=headers, timeout=<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> seg <span class="keyword">in</span> playlist.segments:</span><br><span class="line">                <span class="keyword">if</span> seg.absolute_uri[seg.absolute_uri.find(<span class="string">&quot;?&quot;</span>) - <span class="number">5</span>:seg.absolute_uri.find(<span class="string">&quot;?&quot;</span>)] <span class="keyword">not</span> <span class="keyword">in</span> check:</span><br><span class="line">                    check.append(seg.absolute_uri[seg.absolute_uri.find(<span class="string">&quot;?&quot;</span>) - <span class="number">5</span>:seg.absolute_uri.find(<span class="string">&quot;?&quot;</span>)])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(video_path, <span class="string">&quot;ab&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    r = requests.get(seg.absolute_uri, headers=headers, timeout=<span class="number">5</span>)</span><br><span class="line">                    data = r.content</span><br><span class="line">                    size += <span class="built_in">len</span>(data)</span><br><span class="line">                    <span class="keyword">if</span> data:</span><br><span class="line">                        f.write(data)</span><br><span class="line"></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        timeout(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    frame_img = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(video_path):</span><br><span class="line">        cap = cv2.VideoCapture(video_path)</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        frame_list = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 旋转一下</span></span><br><span class="line">            alpha_rotate = math.atan(<span class="number">81</span> / <span class="number">171</span>) * <span class="number">180</span> / math.pi</span><br><span class="line">            <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                frame = rotate(frame, -alpha_rotate)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line">                cv2.imwrite(<span class="string">&quot;xuanzh.png&quot;</span>, frame)</span><br><span class="line">            <span class="keyword">if</span> ret:</span><br><span class="line">                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)</span><br><span class="line">                frame_list.append(frame)</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;所有帧都已经保存完成&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># frame_sample = frame_list[::5]</span></span><br><span class="line">        <span class="comment"># 生成 x-t 图像</span></span><br><span class="line">        xt_img = np.zeros((frames, width_end-width_start), np.uint8)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(frames):</span><br><span class="line">            <span class="comment"># print(&quot;len frame: &quot;, len(frame_list))</span></span><br><span class="line">            cur_frame = cv2.cvtColor(frame_list[k], cv2.COLOR_BGR2GRAY)</span><br><span class="line">            xt_img[k, :] = np.flip(cur_frame[height_start, width_start:width_end])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xt_img, time_cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">image, angle, center=<span class="literal">None</span>, scale=<span class="number">1.0</span></span>):</span><br><span class="line">    <span class="comment"># grab the dimensions of the image</span></span><br><span class="line">    (h, w) = image.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if the center is None, initialize it as the center of</span></span><br><span class="line">    <span class="comment"># the image</span></span><br><span class="line">    <span class="keyword">if</span> center <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        center = (w // <span class="number">2</span>, h // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># perform the rotation</span></span><br><span class="line">    M = cv2.getRotationMatrix2D(center, angle, scale)</span><br><span class="line">    rotated = cv2.warpAffine(image, M, (w, h))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return the rotated image</span></span><br><span class="line">    <span class="keyword">return</span> rotated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   </span><br><span class="line">    url = <span class="string">r&quot;url-to-get-video&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Edg/86.0.622.56&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    image, time_cur = get_xt_img(url)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;lyx_test.png&#x27;</span>, image)</span><br><span class="line">    alpha = get_alpha_confidence(image)</span><br><span class="line">    <span class="built_in">print</span>(alpha)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;xt image&quot;</span>, image)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/22/%E7%9B%B8%E6%9C%BA%E5%9D%90%E6%A0%87-%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/" data-id="clky8whze000ehcu5g5z849hy" data-title="相机坐标_世界坐标转换" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cycleGAN代码分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/01/cycleGAN%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2023-02-01T13:38:58.000Z" itemprop="datePublished">2023-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/01/cycleGAN%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">cycleGAN代码分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文浅析cycleGAN代码，实现对cycleGAN代码有一个基本认识<br>所分析的代码仓库：<a target="_blank" rel="noopener" href="https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix">https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix</a></p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>由于使用到了 abc 模块（一个抽象工具模块），顺带介绍一下python装饰器的使用。<br>装饰器的作用是在不改变原代码的情况下拓展函数功能，经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器包括函数装饰器和类装饰器，其中函数装饰器通过闭包实现（高阶函数的作用）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">use_logging</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;add logging&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> use_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@add_log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bar = add_log(bar)</span></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>如上代码，通过装饰器add_log装饰后的bar() 等价为 add_log(bar)()<br>如果要使用带参数的装饰器，就需要嵌套一层以传入参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">param_log</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">&quot;warn&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;level is warn&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;level is not warn&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@param_log(<span class="params">level=<span class="string">&quot;warn&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am foo&quot;</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>类装饰器通过 init 函数初始化要装饰的函数，具体实现在 call 函数中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class decorator runing&#x27;</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class decorator ending&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<p>abc 模块中定义了抽象方法装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abstractmethod</span>(<span class="params">funcobj</span>):</span><br><span class="line">    funcobj.__isabstractmethod__ = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> funcobj</span><br></pre></td></tr></table></figure>

<h3 id="cycleGAN"><a href="#cycleGAN" class="headerlink" title="cycleGAN"></a>cycleGAN</h3><p>GAN网络的训练方式有点特殊，因此其整体框架稍有不同，下面对其进行分析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> util.image_pool <span class="keyword">import</span> ImagePool</span><br><span class="line"><span class="keyword">from</span> .base_model <span class="keyword">import</span> BaseModel</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> networks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CycleGANModel</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This class implements the CycleGAN model, for learning image-to-image translation without paired data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The model training requires &#x27;--dataset_mode unaligned&#x27; dataset.</span></span><br><span class="line"><span class="string">    By default, it uses a &#x27;--netG resnet_9blocks&#x27; ResNet generator,</span></span><br><span class="line"><span class="string">    a &#x27;--netD basic&#x27; discriminator (PatchGAN introduced by pix2pix),</span></span><br><span class="line"><span class="string">    and a least-square GANs objective (&#x27;--gan_mode lsgan&#x27;).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    CycleGAN paper: https://arxiv.org/pdf/1703.10593.pdf</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">modify_commandline_options</span>(<span class="params">parser, is_train=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Add new dataset-specific options, and rewrite default values for existing options.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            parser          -- original option parser</span></span><br><span class="line"><span class="string">            is_train (bool) -- whether training phase or test phase. You can use this flag to add training-specific or test-specific options.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            the modified parser.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        For CycleGAN, in addition to GAN losses, we introduce lambda_A, lambda_B, and lambda_identity for the following losses.</span></span><br><span class="line"><span class="string">        A (source domain), B (target domain).</span></span><br><span class="line"><span class="string">        Generators: G_A: A -&gt; B; G_B: B -&gt; A.</span></span><br><span class="line"><span class="string">        Discriminators: D_A: G_A(A) vs. B; D_B: G_B(B) vs. A.</span></span><br><span class="line"><span class="string">        Forward cycle loss:  lambda_A * ||G_B(G_A(A)) - A|| (Eqn. (2) in the paper)</span></span><br><span class="line"><span class="string">        Backward cycle loss: lambda_B * ||G_A(G_B(B)) - B|| (Eqn. (2) in the paper)</span></span><br><span class="line"><span class="string">        Identity loss (optional): lambda_identity * (||G_A(B) - B|| * lambda_B + ||G_B(A) - A|| * lambda_A) (Sec 5.2 &quot;Photo generation from paintings&quot; in the paper)</span></span><br><span class="line"><span class="string">        Dropout is not used in the original CycleGAN paper.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        parser.set_defaults(no_dropout=<span class="literal">True</span>)  <span class="comment"># default CycleGAN did not use dropout</span></span><br><span class="line">        <span class="keyword">if</span> is_train:</span><br><span class="line">            parser.add_argument(<span class="string">&#x27;--lambda_A&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">10.0</span>, <span class="built_in">help</span>=<span class="string">&#x27;weight for cycle loss (A -&gt; B -&gt; A)&#x27;</span>)</span><br><span class="line">            parser.add_argument(<span class="string">&#x27;--lambda_B&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">10.0</span>, <span class="built_in">help</span>=<span class="string">&#x27;weight for cycle loss (B -&gt; A -&gt; B)&#x27;</span>)</span><br><span class="line">            parser.add_argument(<span class="string">&#x27;--lambda_identity&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.5</span>, <span class="built_in">help</span>=<span class="string">&#x27;use identity mapping. Setting lambda_identity other than 0 has an effect of scaling the weight of the identity mapping loss. For example, if the weight of the identity loss should be 10 times smaller than the weight of the reconstruction loss, please set lambda_identity = 0.1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, opt</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize the CycleGAN class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            opt (Option class)-- stores all the experiment flags; needs to be a subclass of BaseOptions</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        BaseModel.__init__(self, opt)</span><br><span class="line">        <span class="comment"># specify the training losses you want to print out. The training/test scripts will call &lt;BaseModel.get_current_losses&gt;</span></span><br><span class="line">        self.loss_names = [<span class="string">&#x27;D_A&#x27;</span>, <span class="string">&#x27;G_A&#x27;</span>, <span class="string">&#x27;cycle_A&#x27;</span>, <span class="string">&#x27;idt_A&#x27;</span>, <span class="string">&#x27;D_B&#x27;</span>, <span class="string">&#x27;G_B&#x27;</span>, <span class="string">&#x27;cycle_B&#x27;</span>, <span class="string">&#x27;idt_B&#x27;</span>]</span><br><span class="line">        <span class="comment"># specify the images you want to save/display. The training/test scripts will call &lt;BaseModel.get_current_visuals&gt;</span></span><br><span class="line">        visual_names_A = [<span class="string">&#x27;real_A&#x27;</span>, <span class="string">&#x27;fake_B&#x27;</span>, <span class="string">&#x27;rec_A&#x27;</span>]</span><br><span class="line">        visual_names_B = [<span class="string">&#x27;real_B&#x27;</span>, <span class="string">&#x27;fake_A&#x27;</span>, <span class="string">&#x27;rec_B&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> self.isTrain <span class="keyword">and</span> self.opt.lambda_identity &gt; <span class="number">0.0</span>:  <span class="comment"># if identity loss is used, we also visualize idt_B=G_A(B) ad idt_A=G_A(B)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;!!!!!!!!! use identity loss&quot;</span>)</span><br><span class="line">            visual_names_A.append(<span class="string">&#x27;idt_B&#x27;</span>)</span><br><span class="line">            visual_names_B.append(<span class="string">&#x27;idt_A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.visual_names = visual_names_A + visual_names_B  <span class="comment"># combine visualizations for A and B</span></span><br><span class="line">        <span class="comment"># specify the models you want to save to the disk. The training/test scripts will call &lt;BaseModel.save_networks&gt; and &lt;BaseModel.load_networks&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> self.isTrain:</span><br><span class="line">            self.model_names = [<span class="string">&#x27;G_A&#x27;</span>, <span class="string">&#x27;G_B&#x27;</span>, <span class="string">&#x27;D_A&#x27;</span>, <span class="string">&#x27;D_B&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># during test time, only load Gs</span></span><br><span class="line">            self.model_names = [<span class="string">&#x27;G_A&#x27;</span>, <span class="string">&#x27;G_B&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># define networks (both Generators and discriminators)</span></span><br><span class="line">        <span class="comment"># The naming is different from those used in the paper.</span></span><br><span class="line">        <span class="comment"># Code (vs. paper): G_A (G), G_B (F), D_A (D_Y), D_B (D_X)</span></span><br><span class="line">        self.netG_A = networks.define_G(opt.input_nc, opt.output_nc, opt.ngf, opt.netG, opt.norm,</span><br><span class="line">                                        <span class="keyword">not</span> opt.no_dropout, opt.init_type, opt.init_gain, self.gpu_ids)</span><br><span class="line">        self.netG_B = networks.define_G(opt.output_nc, opt.input_nc, opt.ngf, opt.netG, opt.norm,</span><br><span class="line">                                        <span class="keyword">not</span> opt.no_dropout, opt.init_type, opt.init_gain, self.gpu_ids)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.isTrain:  <span class="comment"># define discriminators</span></span><br><span class="line">            self.netD_A = networks.define_D(opt.output_nc, opt.ndf, opt.netD,</span><br><span class="line">                                            opt.n_layers_D, opt.norm, opt.init_type, opt.init_gain, self.gpu_ids)</span><br><span class="line">            self.netD_B = networks.define_D(opt.input_nc, opt.ndf, opt.netD,</span><br><span class="line">                                            opt.n_layers_D, opt.norm, opt.init_type, opt.init_gain, self.gpu_ids)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.isTrain:</span><br><span class="line">            <span class="keyword">if</span> opt.lambda_identity &gt; <span class="number">0.0</span>:  <span class="comment"># only works when input and output images have the same number of channels</span></span><br><span class="line">                <span class="keyword">assert</span>(opt.input_nc == opt.output_nc)</span><br><span class="line">            self.fake_A_pool = ImagePool(opt.pool_size)  <span class="comment"># create image buffer to store previously generated images</span></span><br><span class="line">            self.fake_B_pool = ImagePool(opt.pool_size)  <span class="comment"># create image buffer to store previously generated images</span></span><br><span class="line">            <span class="comment"># define loss functions</span></span><br><span class="line">            self.criterionGAN = networks.GANLoss(opt.gan_mode).to(self.device)  <span class="comment"># define GAN loss.</span></span><br><span class="line">            self.criterionCycle = torch.nn.L1Loss()</span><br><span class="line">            self.criterionIdt = torch.nn.L1Loss()</span><br><span class="line">            <span class="comment"># initialize optimizers; schedulers will be automatically created by function &lt;BaseModel.setup&gt;.</span></span><br><span class="line">            self.optimizer_G = torch.optim.Adam(itertools.chain(self.netG_A.parameters(), self.netG_B.parameters()), lr=opt.lr, betas=(opt.beta1, <span class="number">0.999</span>))</span><br><span class="line">            self.optimizer_D = torch.optim.Adam(itertools.chain(self.netD_A.parameters(), self.netD_B.parameters()), lr=opt.lr, betas=(opt.beta1, <span class="number">0.999</span>))</span><br><span class="line">            self.optimizers.append(self.optimizer_G)</span><br><span class="line">            self.optimizers.append(self.optimizer_D)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_input</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Unpack input data from the dataloader and perform necessary pre-processing steps.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            input (dict): include the data itself and its metadata information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The option &#x27;direction&#x27; can be used to swap domain A and domain B.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        AtoB = self.opt.direction == <span class="string">&#x27;AtoB&#x27;</span></span><br><span class="line">        self.real_A = <span class="built_in">input</span>[<span class="string">&#x27;A&#x27;</span> <span class="keyword">if</span> AtoB <span class="keyword">else</span> <span class="string">&#x27;B&#x27;</span>].to(self.device)</span><br><span class="line">        self.real_B = <span class="built_in">input</span>[<span class="string">&#x27;B&#x27;</span> <span class="keyword">if</span> AtoB <span class="keyword">else</span> <span class="string">&#x27;A&#x27;</span>].to(self.device)</span><br><span class="line">        self.image_paths = <span class="built_in">input</span>[<span class="string">&#x27;A_paths&#x27;</span> <span class="keyword">if</span> AtoB <span class="keyword">else</span> <span class="string">&#x27;B_paths&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run forward pass; called by both functions &lt;optimize_parameters&gt; and &lt;test&gt;.&quot;&quot;&quot;</span></span><br><span class="line">        self.fake_B = self.netG_A(self.real_A)  <span class="comment"># G_A(A)</span></span><br><span class="line">        self.rec_A = self.netG_B(self.fake_B)   <span class="comment"># G_B(G_A(A))</span></span><br><span class="line">        self.fake_A = self.netG_B(self.real_B)  <span class="comment"># G_B(B)</span></span><br><span class="line">        self.rec_B = self.netG_A(self.fake_A)   <span class="comment"># G_A(G_B(B))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward_D_basic</span>(<span class="params">self, netD, real, fake</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate GAN loss for the discriminator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">            netD (network)      -- the discriminator D</span></span><br><span class="line"><span class="string">            real (tensor array) -- real images</span></span><br><span class="line"><span class="string">            fake (tensor array) -- images generated by a generator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Return the discriminator loss.</span></span><br><span class="line"><span class="string">        We also call loss_D.backward() to calculate the gradients.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Real</span></span><br><span class="line">        pred_real = netD(real)</span><br><span class="line">        loss_D_real = self.criterionGAN(pred_real, <span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># Fake</span></span><br><span class="line">        pred_fake = netD(fake.detach())</span><br><span class="line">        loss_D_fake = self.criterionGAN(pred_fake, <span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># Combined loss and calculate gradients</span></span><br><span class="line">        loss_D = (loss_D_real + loss_D_fake) * <span class="number">0.5</span></span><br><span class="line">        loss_D.backward()</span><br><span class="line">        <span class="keyword">return</span> loss_D</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward_D_A</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate GAN loss for discriminator D_A&quot;&quot;&quot;</span></span><br><span class="line">        fake_B = self.fake_B_pool.query(self.fake_B)</span><br><span class="line">        self.loss_D_A = self.backward_D_basic(self.netD_A, self.real_B, fake_B)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward_D_B</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate GAN loss for discriminator D_B&quot;&quot;&quot;</span></span><br><span class="line">        fake_A = self.fake_A_pool.query(self.fake_A)</span><br><span class="line">        self.loss_D_B = self.backward_D_basic(self.netD_B, self.real_A, fake_A)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward_G</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate the loss for generators G_A and G_B&quot;&quot;&quot;</span></span><br><span class="line">        lambda_idt = self.opt.lambda_identity</span><br><span class="line">        lambda_A = self.opt.lambda_A</span><br><span class="line">        lambda_B = self.opt.lambda_B</span><br><span class="line">        <span class="comment"># Identity loss</span></span><br><span class="line">        <span class="keyword">if</span> lambda_idt &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># G_A should be identity if real_B is fed: ||G_A(B) - B||</span></span><br><span class="line">            self.idt_A = self.netG_A(self.real_B)</span><br><span class="line">            self.loss_idt_A = self.criterionIdt(self.idt_A, self.real_B) * lambda_B * lambda_idt</span><br><span class="line">            <span class="comment"># G_B should be identity if real_A is fed: ||G_B(A) - A||</span></span><br><span class="line">            self.idt_B = self.netG_B(self.real_A)</span><br><span class="line">            self.loss_idt_B = self.criterionIdt(self.idt_B, self.real_A) * lambda_A * lambda_idt</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.loss_idt_A = <span class="number">0</span></span><br><span class="line">            self.loss_idt_B = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># GAN loss D_A(G_A(A))</span></span><br><span class="line">        self.loss_G_A = self.criterionGAN(self.netD_A(self.fake_B), <span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># GAN loss D_B(G_B(B))</span></span><br><span class="line">        self.loss_G_B = self.criterionGAN(self.netD_B(self.fake_A), <span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># Forward cycle loss || G_B(G_A(A)) - A||</span></span><br><span class="line">        self.loss_cycle_A = self.criterionCycle(self.rec_A, self.real_A) * lambda_A</span><br><span class="line">        <span class="comment"># Backward cycle loss || G_A(G_B(B)) - B||</span></span><br><span class="line">        self.loss_cycle_B = self.criterionCycle(self.rec_B, self.real_B) * lambda_B</span><br><span class="line">        <span class="comment"># combined loss and calculate gradients</span></span><br><span class="line">        self.loss_G = self.loss_G_A + self.loss_G_B + self.loss_cycle_A + self.loss_cycle_B + self.loss_idt_A + self.loss_idt_B</span><br><span class="line">        self.loss_G.backward()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">optimize_parameters</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate losses, gradients, and update network weights; called in every training iteration&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        self.forward()      <span class="comment"># compute fake images and reconstruction images.</span></span><br><span class="line">        <span class="comment"># G_A and G_B</span></span><br><span class="line">        self.set_requires_grad([self.netD_A, self.netD_B], <span class="literal">False</span>)  <span class="comment"># Ds require no gradients when optimizing Gs</span></span><br><span class="line">        self.optimizer_G.zero_grad()  <span class="comment"># set G_A and G_B&#x27;s gradients to zero</span></span><br><span class="line">        self.backward_G()             <span class="comment"># calculate gradients for G_A and G_B</span></span><br><span class="line">        self.optimizer_G.step()       <span class="comment"># update G_A and G_B&#x27;s weights</span></span><br><span class="line">        <span class="comment"># D_A and D_B</span></span><br><span class="line">        self.set_requires_grad([self.netD_A, self.netD_B], <span class="literal">True</span>)</span><br><span class="line">        self.optimizer_D.zero_grad()   <span class="comment"># set D_A and D_B&#x27;s gradients to zero</span></span><br><span class="line">        self.backward_D_A()      <span class="comment"># calculate gradients for D_A</span></span><br><span class="line">        self.backward_D_B()      <span class="comment"># calculate graidents for D_B</span></span><br><span class="line">        self.optimizer_D.step()  <span class="comment"># update D_A and D_B&#x27;s weights</span></span><br></pre></td></tr></table></figure>
<p>从forward函数，init函数和optimize_parameters函数进行分析。<br>init函数初始化一些变量，forward函数构建pipeline，具体需要清楚个命名代表什么。<br>real_A –&gt; netG_A –&gt; fake_B –&gt; netG_B –&gt; rec_A<br>real_B –&gt; netG_B –&gt; fake_A –&gt; netG_A –&gt; rec_B<br>每个epoch调用的是 optimize_parameters。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(opt.epoch_count, opt.n_epochs + opt.n_epochs_decay + <span class="number">1</span>): </span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataset):  <span class="comment"># inner loop within one epoch</span></span><br><span class="line">        model.set_input(data)         <span class="comment"># unpack data from dataset and apply preprocessing</span></span><br><span class="line">        model.optimize_parameters()   <span class="comment"># calculate loss functions, get gradients, update network weights</span></span><br></pre></td></tr></table></figure>
<p>关于生成器和判别器是如何搭建的，如无深入研究，建议直接看论文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/01/cycleGAN%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" data-id="clky8whyz0001hcu59cjm74xi" data-title="cycleGAN代码分析" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CRF总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/17/CRF%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-01-17T14:17:23.000Z" itemprop="datePublished">2023-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/17/CRF%E6%80%BB%E7%BB%93/">CRF总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>介绍CRF的文章看起来总是高深莫测，本文不介绍CRF的数学原理，旨在通过实战及定性上对CRF有一个认识。</p>
<h2 id="BERT-Bi-LSTM-CRF实现NER"><a href="#BERT-Bi-LSTM-CRF实现NER" class="headerlink" title="BERT+Bi-LSTM+CRF实现NER"></a>BERT+Bi-LSTM+CRF实现NER</h2><p>参考文章: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/453350271">https://zhuanlan.zhihu.com/p/453350271</a><br>参考代码: <a target="_blank" rel="noopener" href="https://github.com/XavierWww/Chinese-Medical-Entity-Recognition">https://github.com/XavierWww/Chinese-Medical-Entity-Recognition</a></p>
<p>首先需要对NER标注的数据进行预处理得到文字&#x2F;标注对，NER任务有多种标注方式，具体方案在本文不详细阐述，本文旨在展示CRF如何用。<br>直接上 BERT+Bi-LSTM+CRF 模型的代码吧，代码对各个变量代表的意思，及shape进行了详细的标注</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchcrf <span class="keyword">import</span> CRF</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bert_BiLSTM_CRF</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tag_to_ix, embedding_dim=<span class="number">768</span>, hidden_dim=<span class="number">256</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Bert_BiLSTM_CRF, self).__init__()</span><br><span class="line">        self.tag_to_ix = tag_to_ix</span><br><span class="line">        self.tagset_size = <span class="built_in">len</span>(tag_to_ix)</span><br><span class="line">        self.hidden_dim = hidden_dim</span><br><span class="line">        self.embedding_dim = embedding_dim</span><br><span class="line"></span><br><span class="line">        self.bert = BertModel.from_pretrained(<span class="string">&quot;bert-base-chinese&quot;</span>)</span><br><span class="line">        self.lstm = nn.LSTM(input_size=embedding_dim, hidden_size=hidden_dim//<span class="number">2</span>,</span><br><span class="line">                            num_layers=<span class="number">2</span>, bidirectional=<span class="literal">True</span>, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.dropout = nn.Dropout(p=<span class="number">0.1</span>)</span><br><span class="line">        self.linear = nn.Linear(hidden_dim, self.tagset_size)</span><br><span class="line">        self.crf = CRF(self.tagset_size, batch_first=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_features</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">          embeds_out = self.bert(sentence) <span class="comment"># ([64, 228, 768])</span></span><br><span class="line">        enc, _ = self.lstm(embeds_out[<span class="string">&#x27;last_hidden_state&#x27;</span>]) <span class="comment"># ([64, 228, 256])</span></span><br><span class="line">        enc = self.dropout(enc)</span><br><span class="line">        feats = self.linear(enc) <span class="comment"># ([64, 228, 16])</span></span><br><span class="line">        <span class="keyword">return</span> feats</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, sentence, tags, mask, is_test=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="comment"># sentence ([64, 228]) tags ([64, 228]) mask ([64, 228])</span></span><br><span class="line">        <span class="comment"># 64 为 batch size 228为该batch size的最长的句子长度</span></span><br><span class="line">        emissions = self._get_features(sentence)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_test: <span class="comment"># Training，return loss</span></span><br><span class="line">            loss=-self.crf.forward(emissions, tags, mask, reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> loss</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># Testing，return decoding</span></span><br><span class="line">            decode=self.crf.decode(emissions, mask)</span><br><span class="line">            <span class="keyword">return</span> decode</span><br></pre></td></tr></table></figure>
<p>从以上代码可以发现，CRF的训练细节及测试步骤全部封装在CRF类中，训练时调用forward函数，测试时调用decode函数就行。<br>另外值得注意的是每个句子长度不一，怎样训练效率更高且减小pad的影响呢，这里作者的dataloader如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NerDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27; Generate our dataset &#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">      words, tags = self.sents[idx], self.tags_li[idx]</span><br><span class="line">      token_ids = tokenizer.convert_tokens_to_ids(words)</span><br><span class="line">      laebl_ids = [tag2idx[tag] <span class="keyword">for</span> tag <span class="keyword">in</span> tags]</span><br><span class="line">      seqlen = <span class="built_in">len</span>(laebl_ids)</span><br><span class="line">      <span class="keyword">return</span> token_ids, laebl_ids, seqlen</span><br><span class="line"></span><br><span class="line">train_iter = data.DataLoader(dataset=train_dataset,</span><br><span class="line">                              batch_size=ner.batch_size,</span><br><span class="line">                              shuffle=<span class="literal">True</span>,</span><br><span class="line">                              num_workers=<span class="number">4</span>,</span><br><span class="line">                              collate_fn=PadBatch)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PadBatch</span>(<span class="params">batch</span>):</span><br><span class="line">    maxlen = <span class="built_in">max</span>([i[<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> batch])</span><br><span class="line">    token_tensors = torch.LongTensor([i[<span class="number">0</span>] + [<span class="number">0</span>] * (maxlen - <span class="built_in">len</span>(i[<span class="number">0</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> batch])</span><br><span class="line">    label_tensors = torch.LongTensor([i[<span class="number">1</span>] + [<span class="number">0</span>] * (maxlen - <span class="built_in">len</span>(i[<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> batch])</span><br><span class="line">    mask = (token_tensors &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> token_tensors, label_tensors, mask</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出来主要还是DataLoader中collate_fn参数的作用，相当于是告诉DataLoader如何组织 batch 中的每一项。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/17/CRF%E6%80%BB%E7%BB%93/" data-id="clky8whyv0000hcu5frk6et53" data-title="CRF总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-semantic-segment-工程总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/15/semantic-segment-%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2023-01-15T14:30:30.000Z" itemprop="datePublished">2023-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/15/semantic-segment-%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%BB%93/">semantic_segment_工程总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>语义分割有很多实际应用场景，本篇文章结合水位分割做一个总结。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在实际应用场景中，遇到最大的问题是数据的质量问题，一般室外画面光照影响严重，特别是像水面这种受光照影响严重的物质（如果是做图像回归需要特别注意这个问题）。同时摄像头布置也要避免强光影响。而在夜晚这种场景，如果无法使用红外摄像头，肯定是需要灯光照明的，但如果画面中出现强灯光，同时不同站点其光照条件肯定是不同的，这时肯定会影响黑夜的分割效果（光照想太阳光一样，都是影响分割效果的强干扰因素），为了减少灯光因素的影响，需要把这部分切掉再训练。</p>
<p>除了结合工程项目进行特定的数据预处理，一般为了做数据增广，增强模型鲁棒性，语义分割还有很多通用的数据预处理方法，一般随便找个baseline里面都包含了。</p>
<h2 id="标记自己的数据集"><a href="#标记自己的数据集" class="headerlink" title="标记自己的数据集"></a>标记自己的数据集</h2><h2 id="分割模型"><a href="#分割模型" class="headerlink" title="分割模型"></a>分割模型</h2><p>尝试了分水岭算法分割，k-means聚类分割和基于深度网络的分割模型如PSPNet，SPNet，FCN，DeepLabV3等。前两者分割效果不行，后者泛化性不够。<br>从如下图片示例也可以进行一些分析，水面受光照影响比较严重，即使是同一片水域，也会形成局部亮斑，而前两者的主要原理就是根据颜色进行阈值划分，很难准确得将整片水域正确分割出来。<br><img src="/../images/water_segment.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/15/semantic-segment-%E5%B7%A5%E7%A8%8B%E6%80%BB%E7%BB%93/" data-id="clky8whz50008hcu55k71ferg" data-title="semantic_segment_工程总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-image-to-image" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/11/image-to-image/" class="article-date">
  <time class="dt-published" datetime="2023-01-10T16:16:21.000Z" itemprop="datePublished">2023-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/11/image-to-image/">image-to-image</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>让机器生成我们想要的图像是一件很酷的事情，本文总结一下图像生成的paper</p>
<h2 id="Generative-Adversarial-Nets-2014"><a href="#Generative-Adversarial-Nets-2014" class="headerlink" title="Generative Adversarial Nets[2014]"></a>Generative Adversarial Nets[2014]</h2><p>对于一般的任务比如图像识别我们有一个确定的类别来训练网络结构，将这成为判别算法。但是有一些情况是没有唯一真实标签的，比如我们只想生成带有数字的图片，至于这个数字是多少，数字写得好不好看不重要，只要是数字就行，也就是符合数字的这样一个特征分布，这时就没法直接用标签来训练网络结构了，于是引入了判别器，用于判断生成的分布是否与目标领域分布相同。<br>整个训练过程有必要了解<br><img src="/../images/gan_train.png"></p>
<h2 id="Conditional-Generative-Adversarial-Nets"><a href="#Conditional-Generative-Adversarial-Nets" class="headerlink" title="Conditional Generative Adversarial Nets"></a>Conditional Generative Adversarial Nets</h2><p>如果需要生成的不是整个目标图像域的随意一张图片，而是指定类别的图片呢，这时就需要额外添加控制变量<br><img src="/../images/cgan.png"></p>
<h2 id="Invertible-Conditional-GANs-for-image-editing"><a href="#Invertible-Conditional-GANs-for-image-editing" class="headerlink" title="Invertible Conditional GANs for image editing"></a>Invertible Conditional GANs for image editing</h2><p>更进一步，可不可以只改变图像的某些属性，而保留另外一些属性呢，比如给人脸换个发型<br><img src="/../images/icgan.png"></p>
<h2 id="Image-to-Image-Translation-with-Conditional-Adversarial-Networks"><a href="#Image-to-Image-Translation-with-Conditional-Adversarial-Networks" class="headerlink" title="Image-to-Image Translation with Conditional Adversarial Networks"></a>Image-to-Image Translation with Conditional Adversarial Networks</h2><p>一致性损失函数<br>$\mathcal{L}<em>{L 1}(G)&#x3D;\mathbb{E}</em>{x, y, z}\left[|y-G(x, z)|_1\right]$<br>encoder-decoder改成了u-net结构<br><img src="/../images/pix-to-pix-fra.png"><br>如果只让判别器分别是fake还是real太粗糙了，因此作者提出分块判别：This discriminator tries to classify if each N ×N patch in an image is real or fake. </p>
<h2 id="Unpaired-Image-to-Image-Translation-using-Cycle-Consistent-Adversarial-Networks"><a href="#Unpaired-Image-to-Image-Translation-using-Cycle-Consistent-Adversarial-Networks" class="headerlink" title="Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks"></a>Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks</h2><p>闭环思路，不在需要成对的图像训练网络。<br><img src="/../images/cycle_gan.png"><br>另外需要特别注意的是为了防止 生成器G和生成器F互相包庇，需要引入 identity 损失函数，结合框架图就是 x 经过生成器 F 后生成的图像仍然是 x，而y经过生成器G后生成的图片仍然是y<br> $\mathcal{L}<em>{\text {identity }}(G, F)&#x3D;\mathbb{E}</em>{y \sim p_{\text {data }}(y)}\left[|G(y)-y|<em>1\right]+$ $\mathbb{E}</em>{x \sim p_{\text {data }}(x)}\left[|F(x)-x|_1\right]$</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>更新中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/11/image-to-image/" data-id="clky8whz10002hcu59asl2ega" data-title="image-to-image" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/05/%E5%9F%BA%E4%BA%8Epython%E5%8F%8Ac-%E7%9A%84%E6%B5%B7%E5%BA%B7%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/">基于python及c++的海康摄像头二次开发</a>
          </li>
        
          <li>
            <a href="/2023/06/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/">基于python的循环队列</a>
          </li>
        
          <li>
            <a href="/2023/04/19/pytorch%E5%8F%8A%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0python%E5%BA%93%E4%BB%8B%E7%BB%8D/">pytorch及其他一些深度学习python库介绍</a>
          </li>
        
          <li>
            <a href="/2023/04/07/m3u8%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD/">m3u8视频下载</a>
          </li>
        
          <li>
            <a href="/2023/03/06/diffusion-model/">diffusion_model</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 sunzx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>